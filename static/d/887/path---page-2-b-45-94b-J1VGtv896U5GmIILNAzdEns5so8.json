{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"52980ba9-6383-5a2b-ba8a-290acc595c6e","frontmatter":{"title":"Vim 折腾记","date":"2017/02/19","tags":["Vim"]},"excerpt":"昨天在微信读书上面看到了池建强的《MacTalk 人生元编程》，然后花了差不多一天看完，其中有篇有关于 Vim 的文章提起了我对这个编辑器的再一次兴趣（对的，我对它感兴趣很多次了，每次都懒..）。 一直懒得去慢慢配置它，又不想用别人的配置。自己用的编辑器还是想自己折腾，然后今天…","timeToRead":3}},{"node":{"id":"9ff105f3-4058-51d1-a7e6-3f46af6ed9b5","frontmatter":{"title":"JavaScript 继承的那些事","date":"2017/01/24","tags":["JavaScript","前端"]},"excerpt":"众所周知，JavaScript 的继承是实现继承，而没有 Java 中的接口继承。这是因为 JavaScript 中函数没有签名，而实现继承依靠的是原型链来实现的。 原型链继承 JavaScript 中通过修改对象原型指向的对象来实现继承，即是将一个对象的原型指向要继承的对象实…","timeToRead":2}},{"node":{"id":"0f59c187-906a-52c0-ba09-4c6fbdcca62c","frontmatter":{"title":"从零开始制作 Hexo 主题","date":"2016/12/15","tags":["Hexo","前端"]},"excerpt":"写在前面 本文将会从零开始开发一个简单的博客主题。样式主要参考  Hexo theme  中的  Noise  主题。 开始之前你需要了解： 模板引擎 CSS预处理器 Hexo 文档 本文使用的模板引擎为  ejs ，使用的 CSS 预处理器为  stylus 。这也是 hex…","timeToRead":10}},{"node":{"id":"8cd8f153-2dfc-515c-8cb6-7d0dd249d7a3","frontmatter":{"title":"2016 年终总结","date":"2016/12/13","tags":["年终总结"]},"excerpt":"一转眼 2016 年就快要结束了，这一年对自己来说收获了很多。 去年的总结，给自己定下了个 2016 年的计划。现在 2016 也差不多快结束了，我对自己执行的情况还是比较满意的。 关于 Github 去年年底参加了 Github 上的一个编程马拉松，一开始 commit 都是…","timeToRead":1}},{"node":{"id":"d5810eec-a616-5195-a351-12ebf2e6e4fd","frontmatter":{"title":"JavaScript 创建对象的一些姿势","date":"2016/11/30","tags":["JavaScript","前端"]},"excerpt":"工厂模式 在函数中创建 Object 对象，并为对象添加属性。函数返回添加属性之后的对象。 但工厂模式产生的对象依旧为 Object 类型，只是在对象上添加了一些属性。 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型） 构造函数模…","timeToRead":2}},{"node":{"id":"e1d32326-062e-5909-b07c-c7dba7524f0b","frontmatter":{"title":"JavaScript 数据类型判断","date":"2016/11/21","tags":["JavaScript","前端"]},"excerpt":"最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。 Object.prototype.toString() 在进行类型判断时，使用到最多的当属  。  方法返回一个代表该对象的字符串。每个对象都…","timeToRead":2}},{"node":{"id":"9e3abe8d-4b7e-5a17-8de1-7a189c4d9be8","frontmatter":{"title":"「微信小程序」入坑总结","date":"2016/11/14","tags":["JavaScript","Wechat"]},"excerpt":"前段时间去了广州参加了关于「微信小程序」的技术沙龙，整场下来收获颇多。实际上微信小程序刚刚发布出来的时候就关注，弄了破解了的开发工具，跑了个官方的 Demo。 听完回来之后就想着挖个相关的坑，正好看到手机上的 「ONE · 一个」。上网找到了 ONE 的接口，打算搞一个仿照 O…","timeToRead":2}},{"node":{"id":"17a92045-c7ab-580c-9e0f-e54da4c5ed70","frontmatter":{"title":"React 路由跳转后回到页面顶部","date":"2016/10/11","tags":["React","前端","JavaScript"]},"excerpt":"在 React 组件间进行页面跳转后，发现页面的位置并不在页面顶部，而是在页面跳转前的位置。就是说浏览器的滚动条并没有回到顶部的位置。 经过搜索之后找到了解决方案： Scroll to the top of the page after render in react.js 可…","timeToRead":1}},{"node":{"id":"8f6454e2-af9a-55a8-9ff1-24b034b65470","frontmatter":{"title":"React 生命周期函数小结","date":"2016/10/02","tags":["JavaScript","前端","React"]},"excerpt":"生命周期函数是指，在组件生命周期上的特定点上执行的各个函数。\nReact 的组件声明周期函数分为三种：挂载，更新以及卸载。 挂载 组件挂载的生命周期函数都在初始化渲染前后被调用。 componentWillMount 只调用一次，在客户端与服务端都执行。在初始化渲染之前被调用。…","timeToRead":1}},{"node":{"id":"8af140d3-7488-5fc5-ba79-c51dacfddc96","frontmatter":{"title":"正则表达式备忘录","date":"2016/09/13","tags":["JavaScript","前端","RegExp"]},"excerpt":"JavaScript 创建正则表达式有两种方式： 使用正则表达式字面量： 调用 RegExp 对象的构造函数： 什么时候使用构造函数？ 当正则表达式的模式会变发生改变，或者需要从其他地方得到时（例如用户输入），适合使用构造函数的方式。 匹配字符表 ：将其后的特殊字符转义为字面量…","timeToRead":1}},{"node":{"id":"fa5f0d30-7644-52a1-a118-5efa4e5d6265","frontmatter":{"title":"JavaScript 最佳实践","date":"2016/08/31","tags":["JavaScript","前端"]},"excerpt":"翻译自： JavaScript Best Practices: Tips & Tricks to Level Up Your Code \n没有严格的按照原文翻译，删减修改了部分内容。 在这个教程中，会列出一些重要的 JavaScript 的最佳实践，学习这些并不会很困难。 避免…","timeToRead":3}},{"node":{"id":"a613dcf6-acba-5967-b21c-898abaa8cc8b","frontmatter":{"title":"如何减少浏览器回流","date":"2016/08/02","tags":["JavaScript","前端"]},"excerpt":"什么是浏览器回流 浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。 触发浏览器回流的操作： 在 DOM 中插入，移除或者…","timeToRead":2}},{"node":{"id":"e3ee19c8-4551-5763-98cc-20ecba9a8b5d","frontmatter":{"title":"数组乱序的正确姿势","date":"2016/07/25","tags":["JavaScript","前端","Underscore"]},"excerpt":"在   中有一个函数，其作用是将数组乱序排序，实现如下： 其中使用的数组乱序的算法是  Fisher–Yates shuffle 。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。 每次循环从前面的   个元素中随机选择一个元素  。将这个元素与第   个元素进行交换，…","timeToRead":1}},{"node":{"id":"a8456a05-0a1c-5d8b-86fe-38e355d4f7b6","frontmatter":{"title":"Vue 中使用 highlight.js","date":"2016/07/13","tags":["Vue","前端"]},"excerpt":"今天遇到一个问题：在使用 vue 的练手项目中，渲染的 HTML 里   标签中的代码没有代码高亮。 遂想到用 highlight.js 来解决，按照平常那样在 HTML 文件中引入   和   文件，然后在  中加上一句  。但是却没有效果。 在 Vue.js 的论坛上找到了…","timeToRead":1}},{"node":{"id":"d73c4588-5fae-5c51-8538-4cc5c4fad32e","frontmatter":{"title":"CSS 实现垂直居中","date":"2016/06/29","tags":["CSS","前端"]},"excerpt":"我们有这样一个结构的 HTML： 如果我们要实现   在   中垂直居中。 通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过   与   各偏移 50% 父元素宽度，使用   来修正子元素的位置。 通过这种方式可以使得子元素在父…","timeToRead":1}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"page":2,"skip":15,"limit":15,"total":50}}