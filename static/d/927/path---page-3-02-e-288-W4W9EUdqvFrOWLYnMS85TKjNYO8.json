{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"23928e73-7e20-5e0c-a3ff-18a233730775","frontmatter":{"title":"React 路由跳转后回到页面顶部","date":"2016/10/11","tags":["React","前端","JavaScript"]},"excerpt":"在 React 组件间进行页面跳转后，发现页面的位置并不在页面顶部，而是在页面跳转前的位置。就是说浏览器的滚动条并没有回到顶部的位置。 经过搜索之后找到了解决方案： Scroll to the top of the page after render in react.js 可…","timeToRead":1}},{"node":{"id":"0fb22df8-02b0-5f56-8f24-4c5948dadd05","frontmatter":{"title":"React 生命周期函数小结","date":"2016/10/02","tags":["JavaScript","前端","React"]},"excerpt":"生命周期函数是指，在组件生命周期上的特定点上执行的各个函数。\nReact 的组件声明周期函数分为三种：挂载，更新以及卸载。 挂载 组件挂载的生命周期函数都在初始化渲染前后被调用。 componentWillMount 只调用一次，在客户端与服务端都执行。在初始化渲染之前被调用。…","timeToRead":1}},{"node":{"id":"9838f9e1-d4fc-5c78-8804-daead40db6ef","frontmatter":{"title":"正则表达式备忘录","date":"2016/09/13","tags":["JavaScript","前端","RegExp"]},"excerpt":"JavaScript 创建正则表达式有两种方式： 使用正则表达式字面量： 调用 RegExp 对象的构造函数： 什么时候使用构造函数？ 当正则表达式的模式会变发生改变，或者需要从其他地方得到时（例如用户输入），适合使用构造函数的方式。 匹配字符表 ：将其后的特殊字符转义为字面量…","timeToRead":1}},{"node":{"id":"04aed588-7516-5718-b1dd-d8d54f70248c","frontmatter":{"title":"JavaScript 最佳实践","date":"2016/08/31","tags":["JavaScript","前端"]},"excerpt":"翻译自： JavaScript Best Practices: Tips & Tricks to Level Up Your Code \n没有严格的按照原文翻译，删减修改了部分内容。 在这个教程中，会列出一些重要的 JavaScript 的最佳实践，学习这些并不会很困难。 避免…","timeToRead":3}},{"node":{"id":"ddd66b81-277d-5cfc-a631-40c39ed9a40f","frontmatter":{"title":"如何减少浏览器回流","date":"2016/08/02","tags":["JavaScript","前端"]},"excerpt":"什么是浏览器回流 浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。 触发浏览器回流的操作： 在 DOM 中插入，移除或者…","timeToRead":2}},{"node":{"id":"a7386d49-d9ab-5164-acbe-9570234e84af","frontmatter":{"title":"数组乱序的正确姿势","date":"2016/07/25","tags":["JavaScript","前端","Underscore"]},"excerpt":"在   中有一个函数，其作用是将数组乱序排序，实现如下： 其中使用的数组乱序的算法是  Fisher–Yates shuffle 。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。 每次循环从前面的   个元素中随机选择一个元素  。将这个元素与第   个元素进行交换，…","timeToRead":1}},{"node":{"id":"d2d1aa14-2094-5253-931a-ccb68f791df7","frontmatter":{"title":"Vue 中使用 highlight.js","date":"2016/07/13","tags":["Vue","前端"]},"excerpt":"今天遇到一个问题：在使用 vue 的练手项目中，渲染的 HTML 里   标签中的代码没有代码高亮。 遂想到用 highlight.js 来解决，按照平常那样在 HTML 文件中引入   和   文件，然后在  中加上一句  。但是却没有效果。 在 Vue.js 的论坛上找到了…","timeToRead":1}},{"node":{"id":"45018382-86c1-5927-8b85-3734893e3587","frontmatter":{"title":"CSS 实现垂直居中","date":"2016/06/29","tags":["CSS","前端"]},"excerpt":"我们有这样一个结构的 HTML： 如果我们要实现   在   中垂直居中。 通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过   与   各偏移 50% 父元素宽度，使用   来修正子元素的位置。 通过这种方式可以使得子元素在父…","timeToRead":1}},{"node":{"id":"e16d6f29-4f5a-52f9-8b8f-cf03e3aab3f1","frontmatter":{"title":"Sass 初探","date":"2016/06/07","tags":["CSS","Sass"]},"excerpt":"为什么学 Sass 说起来其实很早就知道   这东西。刚开始写 Even 这个博客主题的时候就有在考虑是要用   还是 ，最后用了变量名用   开头的 Less（可能是 PHP 的原因，对   开头的变量名没什么好感）。 最近正在看  ，源码是用 Sass 写的。  之前也是用…","timeToRead":3}},{"node":{"id":"600013e1-4c51-58d0-80e2-04e1a2fcb39c","frontmatter":{"title":"使用 Nokogiri 解析 HTML","date":"2016/05/28","tags":["Nokogiri","Ruby"]},"excerpt":"Nokogiri 是 Ruby 的一个 HTML/XML 文件的解析库。在需要解析 HTML/XML 文件获取数据时，它是一个很好的选择。 解析 HTML 文档 使用   解析 HTML 将会生成  。\n生成该对象的方式有三种，分别是通过字符串解析，通过文件解析，通过网络解析。…","timeToRead":2}},{"node":{"id":"89268327-0fd9-55c8-ad60-6eed2e1b236f","frontmatter":{"title":"使用 JavaScript 实现简单的拖拽","date":"2016/05/14","tags":["JavaScript","前端"]},"excerpt":"步骤 使用 JavaScript 实现拖拽的步骤： 让元素捕获事件（mousedown, mousemove & mouseup） 单击并不释放，触发 mousedown，标记开始拖拽，并获取元素和鼠标的位置 拖动鼠标，触发 mousemove，不断的获取鼠标的位置，并通过计算…","timeToRead":2}},{"node":{"id":"86377414-7f1c-5f89-b7bf-04ad416a8e83","frontmatter":{"title":"记第一次面试","date":"2016/05/14","tags":["面试","实习"]},"excerpt":"记录第一次面试 流水账 想到什么写什么 第一次正正经经的去面试，虽然只是个软件开发暑期实习生。 刚开始是在网上无聊的逛 V2EX 什么的，然后看了看 conde 社区。后来神不知鬼不觉的不知道为什么就跑到了 Ruby China 去了，又神不知鬼不觉的跑去看了招聘的版块。 其实…","timeToRead":1}},{"node":{"id":"cb840a04-20c4-5b6c-b3c1-853309049d81","frontmatter":{"title":"从 optimizeCb 说起","date":"2016/05/03","tags":["JavaScript","前端","Underscore"]},"excerpt":"optimizeCb 在   中的内部函数  ，顾名思义就是 optimize callback，即优化回调函数。 optimizeCb: 它是这样处理回调的，当回调函数指定上下文环境时，根据   来分情况使用  ，不同情况的\n区别只是   除了上下文环境之外的函数参数的个数不…","timeToRead":2}},{"node":{"id":"2ec39d58-5331-5350-a687-7fad199d9ed7","frontmatter":{"title":"不合常理的变量提升","date":"2016/04/28","tags":["JavaScript","前端"]},"excerpt":"变量提升 合乎常理的预期 按照合乎常理的预期，程序应该是由上至下一行一行执行的，如果使用了之前没有定义的变量的话，正确的反应应该是会报错，就象下面这段 C++ 代码： 并不完全正确 实际上合乎常理的预期并不是“完全正确”的，在 JavaScript 中并不符合直觉。 例如这段 …","timeToRead":2}},{"node":{"id":"e49a6101-47e7-5d42-8c38-439e7fdeb27d","frontmatter":{"title":"事件流：冒泡与捕获","date":"2016/04/16","tags":["JavaScript","前端"]},"excerpt":"事件流 事件流描述的是从页面中接收事件的顺序。在 JavaScript 中事件流有两种，一种是由 IE 开发团队提出的事件冒泡流，而另一种是 Netscape 提出的事件捕获流。 事件冒泡 事件冒泡流，即事件开始时由具体的元素接收，然后逐级向上传播，直到 document 对象…","timeToRead":3}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"page":3,"skip":30,"limit":15,"total":58}}