{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"89fcd788-e9ad-5b1e-880c-f98da4f3020c","frontmatter":{"title":"GraphQL 学习笔记","date":"2019/03/30","tags":["GraphQL"]},"fields":{"slug":"/posts/2019033050"},"excerpt":"入门 定义 Query 类型的 schema 进行查询 为每个 API 节点提供 resolver 函数 处理 GraphQL 查询 创建 GraphQL 服务器 将处理 GraphQL 查询的脚本替换会 express API 服务器 客户端发起  GraphQL 请求 在请…","rawMarkdownBody":"\n## 入门\r\n- 定义 Query 类型的 schema 进行查询\r\n- 为每个 API 节点提供 resolver 函数\r\n- 处理 GraphQL 查询\r\n\r\n```js\r\nvar { graphql, buildSchema } = require('graphql');\r\n\r\n// 使用 GraphQL schema language 构建一个 schema\r\nvar schema = buildSchema(`\r\n  type Query {\r\n    hello: String\r\n  }\r\n`);\r\n\r\n// 根节点为每个 API 入口端点提供一个 resolver 函数\r\nvar root = {\r\n  hello: () => {\r\n    return 'Hello world!';\r\n  },\r\n};\r\n\r\n// 运行 GraphQL query '{ hello }' ，输出响应\r\ngraphql(schema, '{ hello }', root).then((response) => {\r\n  console.log(response);\r\n});\r\n```\r\n\r\n## 创建 GraphQL 服务器\r\n将处理 GraphQL 查询的脚本替换会 express API 服务器\r\n\r\n```js\r\nvar express = require('express');\r\nvar graphqlHTTP = require('express-graphql');\r\nvar { buildSchema } = require('graphql');\r\n\r\n// create GraphQL scheme & resovler\r\n\r\nvar app = express();\r\napp.use('/graphql', graphqlHTTP({\r\n  schema: schema,\r\n  rootValue: root,\r\n  graphiql: true,\r\n}));\r\napp.listen(4000);\r\nconsole.log('Running a GraphQL API server at localhost:4000/graphql');\r\n```\r\n\r\n## 客户端发起  GraphQL 请求\r\n在请求的  query 中发送 GraphQL 请求\r\n\r\n```js\r\nvar xhr = new XMLHttpRequest();\r\nxhr.responseType = 'json';\r\nxhr.open(\"POST\", \"/graphql\");\r\nxhr.setRequestHeader(\"Content-Type\", \"application/json\");\r\nxhr.setRequestHeader(\"Accept\", \"application/json\");\r\nxhr.onload = function () {\r\n  console.log('data returned:', xhr.response);\r\n}\r\nxhr.send(JSON.stringify({query: \"{ hello }\"}));\r\n```\r\n\r\n## Schema 类型\r\n默认支持的标量类型有 String、Int、Float、Boolean 和 ID。\r\n\r\n默认情况下，每个类型都是可以为空的 —— 意味着所有的标量类型都可以返回 null。使用感叹号可以标记一个类型不可为空，如 String! 表示非空字符串。\r\n\r\n如果是列表类型，使用方括号将对应类型包起来，如 [Int] 就表示一个整数列表。\r\n\r\n## 传递 schema 参数\r\n可以在 schema 中的字段后定义改字段需要的参数：\r\n\r\n```js\r\ntype Query {\r\n  rollDice(numDice: Int!, numSides: Int): [Int]\r\n}\r\n```\r\n\r\n然后在服务端的 resolver 函数中获取到这些参数：\r\n\r\n```js\r\nvar root = {\r\n  rollDice: function ({ numDice, numSides }) {\r\n    // do somethings\r\n  }\r\n};\r\n```\r\n\r\n### 在 schema 中定义变量\r\n\r\n可以使用 $ 语法来定义一条查询中的变量，并将变量作为单独映射来传递。\r\n\r\n```js\r\nquery RollDice($dice: Int!, $sides: Int) {\r\n  rollDice(numDice: $dice, numSides: $sides)\r\n}\r\n```\r\n\r\n## 自定义对象类型\r\n在 GraphQL schema language 中，定义一个新的对象类型就和定义 Query 类型一样。每个对象可以有返回指定类型的字段，以及带有参数的方法。\r\n\r\n```js\r\ntype RandomDie {\r\n  roll(numRolls: Int!): [Int]\r\n}\r\n\r\ntype Query {\r\n  getDie(numSides: Int): RandomDie\r\n}\r\n```\r\n\r\n对于 resolver 来说，可以通过 ES6 class 来定义类：\r\n\r\n```js\r\nclass RandomDie {\r\n  constructor(numSides) {\r\n    this.numSides = numSides;\r\n  }\r\n\r\n  roll({numRolls}) {\r\n\t  // do somethings\r\n  }\r\n}\r\n\r\nvar root = {\r\n  getDie: function ({numSides}) {\r\n    return new RandomDie(numSides || 6);\r\n  }\r\n}\r\n```\r\n\r\n## 变更和输入类型\r\n在 GraphQL 中，使用 Mutation 作为入口端点即可插入或者修改已有数据。\r\n\r\n```js\r\n// 修改已有数据\r\ntype Mutation {\r\n  setMessage(message: String): String\r\n}\r\n\r\n// 查询数据\r\ntype Query {\r\n  getMessage: String\r\n}\r\n```\r\n\r\n可以通过 `input` 关键字来定义输入类型：\r\n\r\n```js\r\n// 输入参数类型\r\ninput MessageInput {\r\n  content: String\r\n  author: String\r\n}\r\n\r\ntype Message {\r\n  id: ID!\r\n  content: String\r\n  author: String\r\n}\r\n\r\ntype Query {\r\n  getMessage(id: ID!): Message\r\n}\r\n\r\ntype Mutation {\r\n  createMessage(input: MessageInput): Message\r\n  updateMessage(id: ID!, input: MessageInput): Message\r\n}\r\n```\r\n\r\n必须在 GraphQL 查询前面使用关键字 mutation 才能调用变更，并将数据作为 JSON 对象以传入输入类型。\r\n\r\n```js\r\nvar query = `mutation CreateMessage($input: MessageInput) {\r\n  createMessage(input: $input) {\r\n    id\r\n  }\r\n}`;\r\nxhr.send(JSON.stringify({\r\n  query: query,\r\n  variables: {\r\n    input: {\r\n      author: author,\r\n      content: content,\r\n    }\r\n  }\r\n}));\r\n```\r\n\r\n*查询使用 query, 即查询与修改的区别是传入 API 中的 query 参数不同，修改需要以 mutation 开头。不同的服务器实现传递格式应该不同*\r\n\r\n## 通过对象创建 schema\r\n使用 GraphQLSchema 构造函数创建 Schema 时，定义 Query 和 Mutation 类型时不用单纯的 Schema Language，而是像对象一样创建它们。\r\n\r\n```js\r\ntype Query {\r\n  user(id: String): User\r\n}\r\n\r\n// 使用对象创建\r\nvar queryType = new graphql.GraphQLObjectType({\r\n  name: 'Query',\r\n  fields: {\r\n    user: {\r\n      type: userType,\r\n      // `args` 描述了 `user` 查询接受的参数\r\n      args: {\r\n        id: { type: graphql.GraphQLString }\r\n      },\r\n      // resolver \r\n      resolve: function (_, {id}) {\r\n        return fakeDatabase[id];\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n不同的是，使用对象创建 scheme 时会将 resolver 函数一起包括在对象中，而不是分开写。","timeToRead":3}},{"node":{"id":"5aa8313b-f255-5c15-92c2-2d9467e542fe","frontmatter":{"title":"2018年终总结","date":"2018/12/30","tags":["年终总结"]},"fields":{"slug":"/posts/2018123049"},"excerpt":"一眨眼 8102 年都快结束了，年终总结也拖了好几天。今天晚上终于可以静下心来写一写了。 先看一下去年立下的 KPI 完成了多少... 2018 checklist 跟女朋友在杭州工作生活能够顺顺利利 好好赚钱，减轻父母压力，照顾好弟弟 努力工作，在技术上能够更上一层楼 除了读…","rawMarkdownBody":"\n一眨眼 8102 年都快结束了，年终总结也拖了好几天。今天晚上终于可以静下心来写一写了。\n\n先看一下去年立下的 KPI 完成了多少...\n\n## 2018 checklist\n\n- [x] 跟女朋友在杭州工作生活能够顺顺利利\n- [x] 好好赚钱，减轻父母压力，照顾好弟弟\n- [ ] 努力工作，在技术上能够更上一层楼\n- [x] 除了读技术书籍之外，读多一些其他书 (假装完成)\n- [x] 拓展一下兴趣爱好，学会做饭 (学会了一点点)\n- [ ] 多运动，多健身，避免久坐\n\n<!-- more -->\n\n很明显，去年年底聪明的立了一些稍微容易实现的 Flag，导致今年的完成度很高。今年照例还是会为新的一年写个清单，希望未来的一年能够朝着目标前进（当然，肯定是无法百分百完成）。\n\n```js\nconst checklist = [];\n```\n\n## 又一次来到杭州\n\n![飞机窗外](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/8vt9q.jpg)\n\n又一次，不同的是这一次来杭州不是短暂的实习了，而是可能是好几年的工作生活。而且这次的飞机没有延误了，天气也异常的好。\n\n算了算，在杭州也快呆了快一年了，然而除了西湖 & 西湖附近之外没有去过其他地方，有点失败。主要原因还是工作了五天，每到周末都想要有时间可以好好在家里宅着。反观我女朋友就不一样了，一到周末就想着去哪里浪。要不是她，估计我连西湖都懒得去，大部分周末都会被她拉出去逛。不过逛来逛去都是那几个地方，明年要好好熟悉熟悉杭州了，多发掘一些杭州没有去过多地方。\n\n```js\nchecklist.push('多出去不同多地方逛逛');\n```\n\n## 一年胖十斤\n\n去年来杭州的我体重只有  63 KG，今年的我已经飙升到 68 KG 了。相信再过不久就要到达 70 KG 了，很快就会变成正在的女朋友口中的 “肥江” 了。可能是工作之后长期久坐造成了脂肪堆积，这一年将近胖了 10 斤，真的是肥胖抹平了我的“棱角”（脸都没有棱角了，我女朋友如是说）。所以新的一年还是要多多运动的，虽然去年也是这样说的，而且并没有做到。但是今年依旧还是得继续让明年的自己记得这件事，不能继续再长胖了。\n\n```js\nchecklist.push('多运动，少久坐，保持体重');\n```\n\n##  学点其他技能\n\n这一年开始自己做饭了，出门再外总是要吃饭的，不自己做总不能靠着外卖过活吧？所以自然的去年的 KPI 里包含里学会做饭这一项。今年也大概算是完成啦这个目标。学会了做一些菜，勉强还是可以吃的。最拿手的就是咖喱饭 & 酒煮花甲了，虽然这两个菜比较简单，但是我自己倒是觉得做得还蛮好吃的。\n\n不过还是不太喜欢去买菜，后面半年搬到了一个盒马配送能到的地方，简直幸福。做菜愉快多了，当然洗碗依旧是很烦的啊。\n\n年底的时候突然对 Vlog 很感兴趣，尝试拍了几次，但是都不满意，对视频剪辑也是一窍不通。希望来年能够学一学这一方面的东西，剪出一些自己喜欢的片子。一方面是让自己学一门技能，一方面是让生活变得更有味道。等什么时候有钱 & 下定决心了就买一个 Go Pro 来玩玩。\n\n```js\nchecklist.push('学习视频拍摄&剪辑，发一些 Vlog');\n```\n\n## 书还要继续读\n\n去年为了校招看了很多的技术方面的书籍，于是计划着今年要读多些其他的书。但貌似是没有做到..\n\n今年读过的书（包括没有读完）：\n\n* [东方快车谋杀案](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F24153048%2F&query=%E4%B8%9C%E6%96%B9%E5%BF%AB%E8%BD%A6%E8%B0%8B%E6%9D%80%E6%A1%88&cat_id=1001&type=search&pos=1)\n* [贫穷的本质](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F21966353%2F&query=%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8&cat_id=1001&type=search&pos=0)（未读完）\n* [牛奶可乐经济学](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3000997%2F&query=%E7%89%9B%E5%A5%B6%E5%8F%AF%E4%B9%90%E7%BB%8F%E6%B5%8E&cat_id=1001&type=search&pos=0)（未读完）\n* [24 个比利](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26371317%2F&query=24%E4%B8%AA%E6%AF%94%E5%88%A9&cat_id=1001&type=search&pos=0)\n* [深入浅出 Rxjs](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30217949%2F&query=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA+Rxjs&cat_id=1001&type=search&pos=0)\n* [Haskell 趣学指南](https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25803388%2F&query=Haskell+%E8%B6%A3%E5%AD%A6%E6%8C%87%E5%8D%97&cat_id=1001&type=search&pos=0)（未读完）\n* [JavaScript 函数式编程指南](https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)\n\n与实际中的预想有些偏差，有三本书读到一半就没有继续读了。主要还是因为搬家打乱了原先上班路上看书读节奏（借口），有一段时间基本上都没有怎么看书。直到年末的时候看了本《24 个比利》，读完这本书的感受就是也许每个人的心里都会有不同的“比利”存在，也许只是我们没有发现而已。也许大学之前的我其实是另一个我？\n\n多读些非技术书籍的目标没有实现，大部分还是看技术相关的居多。新的一年依旧是要继续看书的，但是这次的目标不一样了。\n\n2019 年希望自己能够多看几本英文原版书籍，从简单的慢慢看起。至于看什么类型的书，随缘好了。为什么会有这种想法呢？因为好多时候想看的书都是英文的，而自己的英语阅读能力比较差，便成了想看而无法看的境地。所以先挑一个软柿子捏，决定了就是哈利波特了，祝自己好运～\n\n```js\nchecklist.push('多阅读，尝试读一些英文原版书籍');\n```\n\n## 博客几乎没有写\n\n个人博客在这一年几乎是废弃的。到目前为止，包括这一篇年终总结，今年的博客文章总共就三篇。另外的两篇分别是读书笔记和踩坑总结。\n\n个人在技术上基本上都没有输出，惭愧惭愧。新的一年一定要重新写起来。实际上，这一年在业余时间也是接触了一些新技术的，WebAssembly，Web Components 之类的。但是基本都没有太过深入，后续如果有深入的话一定要输出一些文章出来（又立 Flag）。\n\n今年的博客日PV：\n\n![博客日PV](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/c8g7c.png)\n\n理所应当的数据很惨淡，毕竟只能依靠着去年的老文章过活。给明年的自己定一个可量化的目标：博客的日平均 PV 达到 500 人次。\n\n```js\nchecklist.push('多写文章，目标博客日平均 PV 500');\n```\n\n## 没有 Side Project\n\n照例，总结里头是少不了 Github 的 contributions 图的：\n\n![github](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/kikzc.png)\n\n但基本上是没有什么业余的个人项目了，博客主题也少有维护了。主要一个还是太忙，下班完完全是不想碰电脑的。这样其实不太好，业余没有积累的话就会越来越没有竞争力的。大部分的 commit 都是修改 [dotfiles](https://github.com/ahonn/dotfiles)，毕竟这个是我每天都会使用的。至于明年，肯定是不能跟今年一样懈怠的。准备写一写自己常用的一些工具软件，例如造一个 TODO APP 之类的，具体没有想好。目标是能够学一些新东西运用起来。\n\n```js\nchecklist.push('用新技术造一些自己常用的工具软件');\n```\n\n## 工作是要解决问题\n\n正式工作之后，发现和自己原来想象的不太一样。并不是大公司里面的员工技术就强，而是他们都能够去解决问题，不限于通过技术手段解决。技术只是解决问题的一个手段，一个辅助。更多时候需要能够去解决问题，而不是要技术有多么的强。\n\n今年在工作上对某些技术之外的处理还有欠妥，给别人造成了不必要的麻烦。虽然是新人，但其实也应该去尝试 hold 住。这让我意识到软实力也很重要，所以今年的目标之一是能够在工作中更加从容的去解决问题，多学习一些软技能。如何去与人更好的沟通，如何去推动其他人一起把问题解决，如何在逆境中更好的处理事情。这些都是未来要好好学习的。\n\n即使是程序猿，也不应该只把自己局限在这之内。Developer === Resolver\n\n来年要把该做的工作都做好，并且尽量能够做超出预期，软硬兼顾。\n\n```js\nchecklist.push('更好的完成工作，软硬兼顾');\n```\n\n\n\n## // TODO: 2019\n\n到这里，2018 年的总结就差不多写完了。列一下上面为明年定下了那些 KPI：\n\n```js\nconsole.log(checklist);\n```\n\n- 多出去不同多地方逛逛\n- 多运动，少久坐，保持体重\n- 学习视频拍摄&剪辑，发一些 Vlog\n- 多阅读，尝试读一些英文原版书籍\n- 多写文章，目标博客日平均 PV 500\n- 用新技术造一些自己常用的工具软件\n- 更好的完成工作，软硬兼顾\n\n看起来差不多了，当然理论上是不存在全部完成的。最后加上一条一定要完成的 KPI：\n\n```js\nchecklist.push('与女朋友一起好好生活');\n```\n\nKeep learning & Happy life ...\n","timeToRead":4}},{"node":{"id":"05dc30a2-18b4-51fd-ae46-dba7c139b821","frontmatter":{"title":"new Date(string) 在不同浏览器中的不同表现","date":"2018/11/17","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2018111748"},"excerpt":"最近在开发中使用了   去判断字符串是否为日期格式字符串。发现当字符串为   时，在 Chrome 中   返回值为 true, 而当字符串为   时则正确返回 false。而 Safari 则没有该问题，全部返回 false。 moment 解析字符串构造 Date 对象的过…","rawMarkdownBody":"\n最近在开发中使用了 `moment(string).isValid()` 去判断字符串是否为日期格式字符串。发现当字符串为 `xxxx-1` 时，在 Chrome 中 `moment('test-1').isValid()` 返回值为 true, 而当字符串为 `test1` 时则正确返回 false。而 Safari 则没有该问题，全部返回 false。\n\n<!--more-->\n\nmoment 解析字符串构造 Date 对象的过程中会经过内置的解析函数解析字符串，再通过 `new Date (year, month[, date[ ,hours[ ,minutes [, seconds[ ,ms ]]]]])` 来构造 Date 对象。把 `test-1` 传入 moment 时，默认的解析函数没有解析出结果，则将 `test-1` 直接丢给 `new Date(string)` 处理。\n\n通过 [ECMAScript® 2015 Language Specification](https://www.ecma-international.org/ecma-262/6.0/#sec-date-value) :\n![ECMAScript](https://cdn.nlark.com/lark/0/2018/png/50606/1542262842829-ec1d3d9e-6b5f-4113-bd02-2640fcb7d6fd.png)\n\n可知当调用 `new Date(string)` 时实际上约等于 `Date.parse(string)` 来处理传入的字符串。由 Date.parse(string) 的实现上实际看不出什么来。但 [Date.parse() - JavaScript | MDN - Mozilla](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) 上写了这么一句：“不推荐在ES5之前使用Date.parse方法，因为字符串的解析完全取决于实现。直到至今，不同宿主在如何解析日期字符串上仍存在许多差异，因此最好还是手动解析日期字符串”\n\n实际实验 Safari 的输出:\n\n![Safari Date.parse](https://cdn.nlark.com/lark/0/2018/png/50606/1542263179353-6b393f5e-242e-4c20-8e52-050d1a93b878.png)\n\n以及 chrome 的输出：\n\n![Chrome Date.parse](https://cdn.nlark.com/lark/0/2018/png/50606/1542263243746-88db04f3-aa20-4d87-8f5f-8f6a2de5a241.png)\n\n验证了 MDN 上的说法，所以通过 `new Date(string)` 返回值是否为 `Invalid Date` 判断或者通过 `moment(string).isValid()`\n返回值判断对应的字符串是否为日期时间格式字符串是不靠谱的。\n\n正确的做法应该是通过传入解析格式来使用 `moment(string, format).isValid()` 来进行判断。\n\n","timeToRead":1}},{"node":{"id":"04c1f150-3fd3-55a1-ac79-ab0540718291","frontmatter":{"title":"JavaScript 函数式编程笔记","date":"2018/09/15","tags":["JavaScript","FP"]},"fields":{"slug":"/posts/2018091547"},"excerpt":"本文为  JS 函数式编程指南   笔记 函数是一等公民 当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。 纯函数 相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如   是纯函数，而   不是纯函数。 只要…","rawMarkdownBody":"\n> 本文为 [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/cotent/)  笔记\n\n## 函数是一等公民\n当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。\n\n## 纯函数\n相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如 `Array.prototype.slice` 是纯函数，而 `Array.prototype.splice` 不是纯函数。\n\n只要函数跟外界环境发生交互，就是有副作用。但并不是说要禁止副作用，函数式的编程哲学是假定副作用是造成不正当行为的主要原因。\n\n<!--more-->\n\n纯函数的好处：\n- 可缓存性 Cacheable\n- 可移植性 Portable\n- 可测试性 Testable\n- 合理性 Reasonable (引用透明)\n\n## 柯里化\n只传递一个参数来调用它，然后返回另一个函数处理剩下的参数，称为柯离化，也叫做局部调用。\n\n```js\nconst _ = require('lodash/fp')\n\nconst add = _.curry((a, b) => a + b)\n\nconst add2 = add(2)\n\nadd2(3) // 5\n```\n\n## 组合\n通过组合两个或多个函数返回一个新的函数，例如:\n\n```js\nconst g = n => n + 1;\nconst f = n => n * 2;\n\nconst fn = compomse(f, g);\n\nfn(1); // => f(g(1)) => 4\n```\n\n在 compomse 中，g 将先于 f 执行，因此创建了一个从右到左的数据流。\n\n*结合律：compomse(f, compomse(g, h)) 等同于 compomse(compomse(f, g), h)*\n\n## pointfree\n    “Love means never having to say you're sorry”\n\npointfree 模式是指永远不需要声明数据。\n\n以一个不恰当的代码比喻：\n```js\nconst hello = name => console.log(`hello ${name}`);\n\n// not pointfree\nconst sayHello = (name) => {\n  return hello(name);\n}\n\n// pointfree\nconst sayHello = hello\n```\n\nPS: 个人理解，pointfree 即是指函数仅只是其他函数的组合，并不需要指定外部的数据，函数中也不需要传入外部变量。\n但这无法绝对避免，例如获取某个时间字符串的时间戳：`const timestamp = (date) => (new Date(date)).getTime()`。\n\n## debug\n在函数的组合中需要进行 debug 的话，可以使用 `trace` 函数。\n\n```js\n  const trace = curry((tag, value) => {\n    console.log(tag, value);\n    return value;\n  });\n```\n\n将 `trace` 函数插入到 `compomse` 中即可检查上一个函数返回值是否正确。\n\n## identity\n范畴学中独特的态射，这个函数接受随便什么东西，然后原封不动的吐出来。一个假装自己是普通数据的函数。\n\n```js\nconst identity = x => x;\n```\n\nidentity 函数可以一起使用，但是看起来好像是没有卵用：\n```js\ncompomse(identity, f) == compomse(f, identity) == f\n```\n\n## 类型签名\n\n接受具体类型，返回具体类型：\n```js\n// hello::String -> String\nconst hello = name => `hello ${name}`;\n```\n\n接受任意类型，并返回相同类型：\n```js\n// identity::a -> a\nconst identity = n => n\n```\n\n接受函数参数：\n```js\n// map::(a -> b) -> ![pic](a) -> ![pic](b)\nconst map = curry((f, xs) => xs.map(f));\n```\n\n### 类型约束\n```js\n// sort::Ord a => ![pic](a) => ![pic](a)\nconst sort = balabala\n```\n\n胖箭头的左边表明 a 一定是一个 Ord 对象，也就是说 a 必须要实现 Ord 接口（可排序）。\n\n通过这种方式能够限制函数的作用范围，这种接口声明叫做类型约束。\n\n## functor\n\n```js\nconst Functor = (x) => {\n  this.__value = x;\n};\n\nFunctor.of = x => new Functor(x);\n\nFunctor.prototype.map = f => Functor.of(f(this.__value));\n```\n\nfunctor 是实现了 `map` 函数，并遵守某些特点规则的容器类型，具有 `mappable` 的特点（类似于 Promise 的 thenable）。\n\n### Maybe\nMaybe 是另一种 functor，实际上只是多了空值检查。\n\n```js\nconst Maybe = (x) => {\n  this.__value = x;\n};\n\nMaybe.of = x => new Maybe(x);\n\nMaybe.prototype.isNothing = () => this.__value === null || this.__value === undefined;\n\nMaybe.prototype.map = f => this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n```\n\nMaybe 使得在 `map` 调用中产生 null 或者 undefined 时不会爆出错误，而是最后返回 `Maybe.of(null)`。\n\n### Either\nEither 又是另外一种 functor, 不同于正常的 functor, Either 不管怎么 map 都不会改变自己的值。\n\n```js\nconst Either = (x) => {\n  this.__value = x;\n};\n\nEither.of = x => new Either(x);\n\nEither.prototype.map = () => this;\n```\n\nEither 用于错误处理，当出现错误时我们返回一个 `Either.of(error)`, 它将把错误带到最后，并显示出来。\n实际上它就是一个错误消息的 functor, 只是指不会被改变。\n\n### IO\nIO 又又是另外一种 functor, 与最普通的 functor 的差别是，IO 的 `__value` 是一个函数（不过，我们把它当成是数据）。\n\n```js\nconst IO = (f) => {\n  this.unsafaPerfromIO = f;\n};\n\nIO.of = x => new IO(() => x);\n\nIO.prototype.map = f => IO.of(compomse(f, this.unsafaPerfromIO));\n```\n\nIO 把非纯的动作捕获到包裹函数中，延迟执行非纯的动作。并且，假装 IO 的返回指不是包裹函数本身，而是包裹函数执行后的返回值。\n\n当需要获取 IO 的值的时候，就执行 `IO.unsafaPerfromIO()`（此时才会执行整个过程 map by map）。\n\n## Monad\n  pointed functor 是指实现了 `of` 方法的 functor\n\n  monad 是可以变扁的 pointed functor\n\nmonad 主要的使用场景是用来解决嵌套的 functor。\n\n一个 functor，只要它定义了一个 `join` 方法和 `of` 方法，并遵守一些定律，那么它就是一个 monad。\n\n```js\nconst getItem = key => IO.of(() => localStorage.getItem(key));\n\nconst log = x = IO.of(() => {\n  console.log(x);\n  return x;\n});\n\nconst printItem = compomse(join, map(log), getItem);\n\nprintItem('xxx').unsafaPerfromIO();\n```\n\n### chain 函数\n\nchain 函数是 functor map 之后 join 的抽象行为\n```js\nconst chain = curry((f, m) => m.map(f).join());\n```\n\nPS: 其实没有啥用，只是把 `compomse(join, map(log), ...)` 变成了 `compomse(chain(log), ...)`\n\n## Applicative Functor\n\napplicative functor 能够以一种简明扼要的方式把一个 functor 的值应用到另外一个 functor 上。\n\n  applicative functor 是实现了 `ap` 方法的 pointed functor\n\n```js\n// applicative\nFunctor.prototype.ap = other => other.map(this.__value);\n\n// Functor.of(add(2)).ap(Functor.of(3));\n```\n\n`Functor.of(x).map(f)` 等价于 `Functor.of(f).ap(Functor.of(x))`。\n\n### lift\n\n以 pointfree 的方式调用 applicative functor。\n\n```js\nconst liftA2 = curry((f, functor1, functor2) => functor1.map(f).ap(functor2));\n```\n\n### 操作符\n\n  haskell 中可以使用 `<$>` 表示 `map`, `<*>` 表示 `ap`。\n\n```js\nFunctor.of(2).map(add).ap(Functor.of(3));\n// map(add, Functor.of(2)).ap(Functor.of(3));\n```\n\n等同于：\n\n```haskell\nadd <$> Functor 2 <*> Functor 3\n```\n\n## 定律\n- 同一：`A.of(id).ap(v) == v`\n- 同态：`A.of(f).ap(A.of(x)) == A.of(f(x))`\n- 互换：`v.ap(A.of(x)) == A.of(f => f(x)).ap(x)`\n- 组合：`A.of(compomse).ap(u).ap(v).ap(w) == u.ap(v.ap(w))`\n\n","timeToRead":5}},{"node":{"id":"95be07b1-c879-5803-8303-870cd119cec3","frontmatter":{"title":"2017年终总结","date":"2017/12/29","tags":["年终总结"]},"fields":{"slug":"/posts/2017122946"},"excerpt":"恍恍惚惚的，又一年过去了，又到了写年终总结的时间了。 学习 说到学习，这一年学到最多的是开始慢慢的脱离某些学生思维。开始全面的思考问题，对做什么事情都先有一个计划，而不是一股脑的做。就像是编程，应该大部分时间用来思考，而编码实现只是最后的一步操作。 开始慢慢的接触一些能够提升效…","rawMarkdownBody":"\n恍恍惚惚的，又一年过去了，又到了写年终总结的时间了。\n\n## 学习\n说到学习，这一年学到最多的是开始慢慢的脱离某些学生思维。开始全面的思考问题，对做什么事情都先有一个计划，而不是一股脑的做。就像是编程，应该大部分时间用来思考，而编码实现只是最后的一步操作。\n\n开始慢慢的接触一些能够提升效率的工具或者方法，例如年初开始学 vim，虽然说写代码的时候效率的瓶颈并不在敲代码的速度上，但是 vim 的确对编程的体验提高不少。\n\n下半年开始学着用番茄工作法管理时间，提高注意力。目前来说效果还不错，就是有时候番茄间的休息我还是继续在干自己的时候，这一点做得不是很好。毕竟代码一写起来并不是那么好停的。\n\n虽然今年不是太关注 commit，但是依旧还是有着蛮多的记录的。写得比较随性，但是因为太久不写自己会觉得堕落，觉得好像少了点什么，所以总体也只是比去年少了那么一点。\n\n![2017 commit](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/7j9aq.jpg)\n\n<!--more-->\n\n## 读书\n今年也是阅读了不少的书。除了看一些技术相关的书籍之外，看了东野圭吾的几本小说，还有王小波的《沉默的大多数》啥的。\n去年立的 flag 说看完 SICP，今年依旧还是没有完成，至今只看到第四章。最近又开始重新看这本书，希望明年能够看完它。嗯，对。希望可以。\n\n## 工作\n终于，我也开始能把工作这一项加入到年终总结中了。\n\n年初开始为了这一年的校招做准备，最后有惊无险的进了阿里。期间的经历很奇妙，神奇的通过了一轮轮面试，自己竟然有点不敢相信。接着暑假跑去杭州实习了近两个月时间。\n\n第一次独自一人在异乡生活，很多事情刚开始非常不习惯，勉强能够照顾自己。生活质量嘛，就只能呵呵了～在阿里实习期间学到了非常多的东西，主管同事们都非常 nice，总之是一段非常好的经历。有点遗憾的是，杭州西湖也就是远远的瞟了一眼，明年一定要过去溜溜。\n\n接着八月下旬转正答辩完就溜回学校了。还没有回到学校，主管电话过来说答辩过了，好棒～也就这样，我提前结束了我的校招旅程。虽然在此之前也投了其他厂的校招，但是既然已经拿到自己想去的阿里，便没有怎么去管其他的面试了。\n\n## 毕业\n每年看其他师兄师姐的毕业照，总是会滋滋感叹时间过得真快。感叹几次之后，终于到了我了。那天大家都将头发梳成大人模样，穿上帅气西装，仿佛像是要郑重的像青春告别。但我却没有了看别人毕业照时的感叹。只是觉得，哦，我就要毕业了。\n\n在大学里学到了非常非常多的东西，知道了应该怎么正确的处理各种事情。虽然没有经历什么大风大浪，但过得也算是精彩。\n\n## 旅行\n\n今年除了去杭州实习之外，五一跟女朋友去了厦门逛了一圈。对厦门的第一印象是海风很大，虽然是五月，但感觉不到特别炎热。作为一个伪潮汕人，对这种闽南语地区还是非常有好感的～去了鼓浪屿，但是除了拍照蛮好看的之外，感觉并没有什么特别之处。游客太多了，我一向不是很喜欢这种人挤人的地方。\n\n因为今年的嘻哈热潮，国庆的时候又跟女朋友跑去珠海，去沙滩音乐节听沙漠兄弟与 GAI。\n老实说这是第一次去音乐节，感觉还是蛮嗨的。可惜的是，最喜欢的 Jony J 没有来这个音乐节。有时候还蛮想去学学如何 Rap，自己试着去写点歌的。但是，太懒了，哈哈哈。\n\n很遗憾今年周杰伦在佛山的演唱会去不了（主要是没有钱），希望来年有演唱会的话能够到场点歌。\n\n## 计划\n对于 2018 的计划，其实还是蛮多的，对未来充满了憧憬。\n\n- 跟女朋友在杭州工作生活能够顺顺利利\n- 好好赚钱，减轻父母压力，照顾好弟弟\n- 努力工作，在技术上能够更上一层楼\n- 除了读技术书籍之外，读多一些其他书\n- 拓展一下兴趣爱好，学会做饭\n- 多运动，多健身，避免久坐\n\n虽说每年都会列未来一年的计划，但其实并不是每件事情都能做到最好。\n希望自己能够尽自己所能，然后继续加油努力，继续前进。\n\nhappy coding & happy living ...\n\n\n","timeToRead":1}},{"node":{"id":"626f8f35-b8f9-55a7-8abc-5c56a95da3f2","frontmatter":{"title":"从零开始的 Mac","date":"2017/08/31","tags":["MacOS"]},"fields":{"slug":"/posts/2017083145"},"excerpt":"昨天乱搞把电脑搞炸了，然后又误操作把系统格掉了。悲剧.. 除了在 Github 上的代码其他什么东西都没有了，心疼收集了那么久的电子书.. 然后只能重装系统了，想想也好.. 是时候清理清理电脑了，正好借着这个机会整理一下。一开始使用简直烦到不行。没有安装罗技的鼠标驱动，鼠标按键…","rawMarkdownBody":"\n昨天乱搞把电脑搞炸了，然后又误操作把系统格掉了。悲剧.. 除了在 Github 上的代码其他什么东西都没有了，心疼收集了那么久的电子书..\n\n然后只能重装系统了，想想也好.. 是时候清理清理电脑了，正好借着这个机会整理一下。一开始使用简直烦到不行。没有安装罗技的鼠标驱动，鼠标按键无法打开 Launchpad，虽然可以用键盘快捷键，还是觉得很不舒服。还有一个很重点的是没有 Alfred，简直变得生活不能自理了。然后还有很多好用的工具要重新安装，找原先的 iTerm2 配色找了半天.. 所以说论备份的重要性..\n\n<!--more-->\n\n只好从零开始了，下面是一些比较 Nice 的工具：\n\n- Alfred：这个不用说，必备。没有这个我都不会用电脑了\n- Chrome：不解释，还好它能同步回之前的书签什么的\n- Shadowsocks：翻墙必备，没有它简直不像在上网\n- iHosts：修改 host 神器，开放必备\n- iPic：好用的图床工具，一键传上七牛\n- GhostSKB：自动根据 App 切换输入法\n- Dash：文档神器，搭配 Alfred 查 API so easy\n- Magnet：类似 Windows 上的窗口控制，触顶全屏等\n- Jietu：腾讯出品的截图软件，关掉其他截屏只用这个\n- Paste: 剪切板增强，体验超级好\n- Bartender：上面安装了那么多东西菜单栏一堆图标，用这个管理\n\n除了这些 App 还有非常重要的东西要安装：iTerm2 + zsh + oh my zsh，接着把 Neovim 装上下载之前的配置，调整 iTerm2 的配色（现在用的是这个 [vim-hybrid](<https://github.com/w0ng/vim-hybrid>)，主要是配合 Vim 的配色），现在可以美滋滋的写代码了～\n\n等一下，我的 Chrome 插件呢？还好它们都回同步回来，谢天谢地。我的插件主要有这些：\n\n- Octotree：Github 的侧栏目录树\n- GitHub Hovercard：Github Hover 卡片\n- OneTab：开太多标签又不想关掉的时候用这个\n- LassPass：密码同步，没钱买 1Password 的话用这个还是不错的\n- Advertising Terminator：屏蔽广告\n- Proxy SwitchyOmega：网络代理，主要配合 Shadowsocks\n- Vimium：浏览器 Vim 模式，可以丢掉鼠标了\n- Web Timer：统计上网花费时间\n\n然后就是一些经常用的 App 了，Quiver、Pocket、VS Code、网易云音乐之类的。差不多装了该装的东西了，用起来顺心多了... 剩下的就是之后慢慢优化了。\n\n之前不知道 MacOS 有单用户模式..Google 出来的也没人提.. 等我格完盘之后才发现。另外其实我直接重装的话个人数据都还在的.. 说到底还是我自己作死点了格盘.. 说多了都是泪..\n","timeToRead":1}},{"node":{"id":"03d20d43-bbf2-5654-aead-8dcfc0201c88","frontmatter":{"title":"万恶的BOM：ï»¿ 与 \\ufeff","date":"2017/07/24","tags":["CSS","前端"]},"fields":{"slug":"/posts/2017072444"},"excerpt":"最近在搞一个 Sass 文件的编译插件，主要使用 node-sass 来进行编译，在这过程中遇到一个蛮坑的小问题。 在不压缩的情况下使用 node-sass 进行编译的样式文件没有什么问题，可以正确的编译出该有的样式。可是当进行压缩时，就出了问题了。压缩后的文件莫名奇妙的在文件…","rawMarkdownBody":"\n最近在搞一个 Sass 文件的编译插件，主要使用 node-sass 来进行编译，在这过程中遇到一个蛮坑的小问题。\n\n在不压缩的情况下使用 node-sass 进行编译的样式文件没有什么问题，可以正确的编译出该有的样式。可是当进行压缩时，就出了问题了。压缩后的文件莫名奇妙的在文件最开头多了几个奇怪的字符：`ï»¿`。\n\n<!--more-->\n\n本着有什么不懂先 Google 的原则，搜索 `\"ï»¿\"`。发现 stack overflow 上有个相关的问题：[How do I remove ï»¿ from the beginning of a file?](https://stackoverflow.com/questions/3255993/how-do-i-remove-%C3%AF-from-the-beginning-of-a-file)。原来这是一个叫 BOM（Byte Order Mark）的东西，字节顺序标记，出现在文本文件头部，Unicode编码标准中用于标识文件是采用哪种格式的编码。\n\n> 在网页上使用BOM是个错误。BOM设计出来不是用来支持HTML和XML的。\n\n上面这句来自 [「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？](https://www.zhihu.com/question/20167122/answer/14199022) 的回答。我想补充一下，更可恶的事情是 BOM 在 CSS 中。\n\n由于在文件开头多出了一个 BOM，使得压缩后的所有样式都失效了。一开始我尝试在文件最开头加上 `@charset \"utf-8\"`，但是并没有什么用。不过发现了在加上 `@charset \"utf-8\"` 后，变成了这样：\n\n![BOM](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/tnh93.jpg)\n\n多出来的一个小红点，鼠标移上去显示 `\"\\ufeff\"`。找到罪魁祸首了，搜索 `\"\\ufeff\"` 发现有篇关于 JavaScript 中处理 BOM 的文章：[BOM 和 JavaScript 中的 trim](https://imququ.com/post/bom-and-javascript-trim.html)。\n\n最后得到解决方案，在编译后的样式中进行替换，移除 `\\ufeff`:\n\n```js\ncss = css.replace(\"\\ufeff\", \"\");\n```\n\n虽然解决方案蛮简单的，但是在搜索答案与编码测试的过程中学到了蛮多。编码问题还是要注意的，虽然无法避免遇到 utf-8 with BOM，但是也应该尽量只保存为 utf-8 without BOM 编码格式。如果遇到奇怪的字符，那八成就是编码问题了。\n\n\n\n","timeToRead":1}},{"node":{"id":"791a7323-aacb-5b05-883d-a36c5e2b33cb","frontmatter":{"title":"Redux 源码解析","date":"2017/07/04","tags":["Redux","React","Javascript"]},"fields":{"slug":"/posts/2017070443"},"excerpt":"三大原则 单一数据源（store） state 只可读（只能通过 Reducer 生成新 State） 使用纯函数执行修改（Reducer 必须为纯函数，无副作用） 单向数据流  触发 action 传递数据，但应该尽量减少传递的数据 如果有 middleware，在 acti…","rawMarkdownBody":"\n## 三大原则\n- 单一数据源（store）\n- state 只可读（只能通过 Reducer 生成新 State）\n- 使用纯函数执行修改（Reducer 必须为纯函数，无副作用）\n\n<!--more-->\n\n## 单向数据流\n- `dispatch` 触发 action 传递数据，但应该尽量减少传递的数据\n- 如果有 middleware，在 action 发起之后，到达 reducer 之前执行\n- 到达 reducer 之后，根据 action type 返回新 state\n\n## 源码解析\nRedux 提供的 API 主要有：\n- `createStore`: 创建 store 以及提供相关操作\n- `combineReducers`: 合并不同的 reducer 函数\n- `applyMiddleware`: 添加 Redux 中间件\n- `bindActionCreators`: bind action 到组件中\n\n### createStore\n`createStore` 用来创建 Redux store，用于存放所有的 state。\n\n通过 `const store = createStore(reducer, initialState)` 创建 store，只能通过 dispatch action 的方式来改变 state。同时提供了 `getState`，`subscribe` 等方法。\n\n```js\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // ...\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  // ...\n\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n```\n\n当使用 `createStore` 方法时，`dispatch` 了名为 `@@redux/INIT` 的 action。表示已经初始化了 store。\n\n`dispatch` 方法的实现：\n```js\n  function dispatch(action) {\n    // ...\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = currentListeners = nextListeners\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n```\n\n`currentState = currentReducer(currentState, action)` 执行 action 对应的 reducer 操作产生新的 state，如果有监听函数的话，按顺序触发监听函数。\n\n监听函数由 `subscribe` 方法添加，`subscribe` 方法的返回一个 `unsubscribe` 函数，用来取消监听。\n\n`subscribe` 方法的具体实现:\n```js\nfunction subscribe(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Expected listener to be a function.')\n  }\n\n  let isSubscribed = true\n\n  ensureCanMutateNextListeners()\n  nextListeners.push(listener)\n\n  return function unsubscribe() {\n    if (!isSubscribed) {\n      return\n    }\n\n    isSubscribed = false\n\n    ensureCanMutateNextListeners()\n    const index = nextListeners.indexOf(listener)\n    nextListeners.splice(index, 1)\n  }\n}\n```\n\n实际上 `subscribe` 仅是在 `nextListeners` 中添加想要执行的监听函数，并返回了用于删除该函数的 `unsubscribe` 方法\n\n\n### combineReducers\n`combineReducers` 用于合并不同的 reducer 函数，返回唯一的一个 reducer 函数供 `createStore` 使用\n\n```js\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n\t// ...\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // ...\n\n  return function combination(state = {}, action) {\n    // ...\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n\t  // ...\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n```\n\n首先处理传入的 reducer 对象（包含不同的 reducer 函数），得到键值为 function 类型的对象 `finalReducers` 与一个包含其键的数组 `finalReducerKeys`。\n\n`combineReducers` 返回一个 `reducers` 函数用于处理 action，循环所有的 reducers 传入 action 进行处理，当 state 不变时，返回原来的 state\n\n### applyMiddleware\n`applyMiddleware` 的作用是添加中间件并执行中间件，主要是通过 `compose` 函数将所有的中间件串起来\n\n```js\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n重点是 `funcs.reduce((a, b) => (...args) => a(b(...args)))` ，通过函数式编程中常见的 `f(g(args))` 形式串起来，返回一个函数，函数由内到外执行传入之前传入的函数数组，函数的参数将会传递到第一个执行的函数中。\n\n简单的例子：\n```js\nvar f1 = function(a) {\n\tconsole.log('f1: '+ a)\n\treturn a * 10\n}\n\nvar f2 = function(a) {\n\tconsole.log('f2: ' + a)\n\treturn a + 1\n}\nconst funcs = [f1, f2]\n\nconst func = funcs.reduce((a, b) => (...args) => a(b(...args)))\nfunc(1)\n```\n![compose](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6vttf.jpg)\n\n在 applyMiddleware 中 `dispatch = compose(...chain)(store.dispatch)`，即传入 compose 返回的函数的参数为 store 原来的 dispatch 函数。\n\n也就是说，添加了中间件后，执行 dispatch 函数将会首先依次执行传入的中间件, 最后再执行原先的 `store.dispatch`\n\n关于 Redux midddleware 有篇文章写得很不错：[compose and middleware 源码分析](https://github.com/asd0102433/blog/issues/1)\n\n### bindActionCreators\n`bindActionCreators` 方法说白了就是把 action creators 转成拥有同名 keys 的对象，并使用 dispatch 将对象包裹起来，从而能够直接调用函数 dispatch action\n\n```js\nfunction bindActionCreator(actionCreator, dispatch) {\n  return (...args) => dispatch(actionCreator(...args))\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  // ...\n\n  const keys = Object.keys(actionCreators)\n  const boundActionCreators = {}\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\n```\n\n这部分得源码很简单，只是简单的判断 actionCreators，是对象的话就返回一个键值为绑定了 dispatch 的函数的对象\n\n### 思考总结\n很久之前就学会了 Redux 的『使用』，但是却不明白到底是什么实现的，只知道应该那样使用。\n\n阅读了源码之后对 Redux 整个流程更加清晰，有利于之后的使用。也更加理解 Redux 单向数据流的这种思想，虽然使用上更加繁琐，但是如果数据复杂起来，这种单向数据流的管理方式还是利大于弊的。\n\n**参考链接**\n- [Redux 中文文档](http://cn.redux.js.org/index.html)\n- [compose and middleware 源码分析](https://github.com/asd0102433/blog/issues/1)\n","timeToRead":4}},{"node":{"id":"9aacc22c-8a98-5aea-89e1-342398dc60f0","frontmatter":{"title":"Vim 全局搜索插件：ctrlsf.vim","date":"2017/06/29","tags":["Vim"]},"fields":{"slug":"/posts/2017062942"},"excerpt":"这两天一直在看文档看源码，Vim 上用的 Ack.vim 做全局搜索，但是用起来蛮难用的。 经过一番搜索，找到了国人写的全局搜索的插件：ctrlsf.vim，经过配置之后用了起来，感觉蛮好用的。 具体效果可以查看  ctrlsf.vim 安装 ctrlsf 是依赖 ack/ag…","rawMarkdownBody":"\n这两天一直在看文档看源码，Vim 上用的 Ack.vim 做全局搜索，但是用起来蛮难用的。\n\n经过一番搜索，找到了国人写的全局搜索的插件：ctrlsf.vim，经过配置之后用了起来，感觉蛮好用的。\n\n具体效果可以查看 [ctrlsf.vim](https://github.com/dyng/ctrlsf.vim)\n\n<!--more-->\n\n## 安装\nctrlsf 是依赖 ack/ag/pt/rg 之类的，所有必须先安装其中之一。所以我们先安装 ack\n\n```bash\n$ brew install ack\n```\n\n其他系统安装方式查看：https://beyondgrep.com/install/\n\n然后安装 ctrlsf.vim 插件\n\n```viml\nPlug 'dyng/ctrlsf.vim'\n```\n\n运行 `:PlugInstall` 进行安装\n\n## 配置\n我把 `Ctrl-f` 映射到了 `:CrtlSF<Space>`，这样就可以直接 `Ctrl-f` 然后直接输入、回车进行全局搜索了。\n\n```viml\nnnoremap <C-f> :CtrlSF<Space>\n```\n\nctrlsf 插件还提供了两种模式：normal/compact。\nnormal 模式是左半屏为搜索结果，右半屏为预览窗口。而 compact 模式则是类似于 ctrlp 的 quickfix 窗口模式。\n个人还是比较喜欢 quick 窗口模式，可以通过 `let g:ctrlsf_default_view_mode = 'compact'` 设置为默认 compact 模式。\n\n此外通过设置 `let g:ctrlsf_ignore_dir` 指定要搜索时忽略的目录。\n\n## 使用\n设置了快捷键映射之后就可以愉快的 `C-f` 输入回车搜索了。然后可以在搜索结果中移动，预览，打开。还能够按 M 更换显示模式。\n\n具体可以查看：[Key Maps](https://github.com/dyng/ctrlsf.vim#key-maps)\n\n","timeToRead":1}},{"node":{"id":"5a700a84-51ca-5469-a063-1a3379824d90","frontmatter":{"title":"React 初始化渲染","date":"2017/06/08","tags":["React","JavaScript","前端"]},"fields":{"slug":"/posts/2017060841"},"excerpt":"该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分） 源码解析：渲染过程 JSX 解析 我们知道在 React 组件  返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 …","rawMarkdownBody":"\n该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分）\n\n<!--more-->\n\n## 源码解析：渲染过程\n\n### JSX 解析\n\n我们知道在 React 组件`render()` 返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 `React.createElement(type, config, children)`的形式。\n\n```js\n// App.js\n// 转换前\nClass App extends Component {\n    render() {\n        return <h1 id='title'>Hello World<h1>\n    }\n}\n\n// 转换后\nvar App = React.createClass({\n    render() {\n        return React.createElement('h1', {\n            id: 'title'\n        }, 'hello world')\n    }\n})\n```\n\n`React.createElement()` 的实现位于 [/src/isomorphic/classic/element/ReactElement.js](https://github.com/facebook/react/blob/15-stable/src/isomorphic/classic/element/ReactElement.js#L183)\n\n这里的 `React.createElement()`是用来生成虚拟 DOM 元素，该函数对组件的属性，事件，子组件等进行了处理，并返回值为一个 `ReactElement` 对象（单纯的 JavaScript 对象，仅包括 type, props, key, ref 等属性）。\n\n这恰好说明了 JSX 中的 `<h1 id='title'>hello world</h1>`实际上是 JavaScript 对象，而不是我们通常写的 HTML 标签。\n\n### 渲染到页面\n\n单单声明了组件而没有渲染到页面上我们是看不见的（废话），所以我们需要使用 `ReactDOM.render()`将其渲染到页面指定位置上。\n\n```js\n// index.html\n<html>\n    // ...\n    <body>\n        <div id='root'></div>\n    </body>\n</html>\n\n\n// index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App.js'\n\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n`ReactDOM.render()` 的实现位于[ ](https://github.com/facebook/react/blob/master/src/renderers/dom/stack/client/ReactMount.js#L581)[/src/renderers/dom/client/ReactMount.js](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/client/ReactMount.js)\n\n`ReactDOM.render()` 函数将会根据 `ReactElement` 的类型生成相对应的`ReactComponent` 实例，并调用其 `mountComponent()`函数进行组件加载（返回 HTML片段），递归加载所有组件后，通过 [setInnerHTML](https://github.com/facebook/react/blob/b1768b5a48d1f82e4ef4150e0036c5f846d3758a/src/renderers/dom/shared/setInnerHTML.js) 将 HTML 渲染到页面上。\n\n判断需要生成那种 `ReactComponent`实例根据 `ReactElement` 对象的 type 属性来决定。对应 HTML 标签的 type 一般为字符串，而自定义的组件则是大写字母开头的组件函数（自定义组件需要 import，而 HTML 标签不需要）。\n\n#### 生成 **ReactComponent**\n\nReact 中生成对应的 `ReactComponent`实例由 `instantiateReactComponent()`完成，其实现位于 [/src/renderers/shared/stack/reconciler/instantiateReactComponent.js](https://github.com/facebook/react/blob/15-stable/src/renderers/shared/stack/reconciler/instantiateReactComponent.js)\n\n`ReactComponent` 分为 3 种：\n\n* `ReactEmptyComponent`:  空组件（ReactElement 的 type 属性为 null 或 false 的组件），在浏览器中返回 `ReactDOMEmptyComponent`。\n\n* `ReactHostComponent`: 原生组件（ReactElement 为string，number 或 ReactElement 的 type 属性为 string 的组件）。\n\n  * `createInternalComponent()`：该函数用于创建原生组件，在浏览器中返回 `ReactDOMComponent`。\n\n  * `createInstanceForText()` : 该函数用于创建纯文本组件，在浏览器中返回 `ReactDOMTextComponent`。\n\n* `ReactCompositeComponent`: 自定义组件（ReactElement 的 type 属性为 function）\n\n可以发现 React 与平台解耦，使用 `ReactEmptyComponent` 与 `ReactHostComponent`。而这两种组件会根据平台的不同生成不同的组件对象，在浏览器中则为 `ReactDOMEmptyComponent`、`ReactDOMComponent` 与 `ReactDOMTextComponent`。\n\n它们通过 [/src/renderers/dom/stack/client/ReactDOMStackInjection.js](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/stack/client/ReactDOMStackInjection.js) 进行注入。\n\n（ [/src/renderers ](https://github.com/facebook/react/tree/15-stable/src/renderers)路径下包含各个平台上不同的 ReactComponent 实现，包括 react-art/react-dom/react-native。）\n\n## 从零开始：实现初始化渲染\n\n### 设置 babel\n\n首先我们需要了解 babel 如何转换 JSX：[React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/)。\n\nbabel 可以通过`transform-react-jsx`插件来设置解析 JSX 之后调用的函数，默认解析为调用 `React.createElement()`。所以这就是为什么虽然在 JSX 代码中没有使用到 React，却仍然需要导入它。\n\n通过配置 `transform-react-jsx`插件的 `pragma`选项可以修改解析后调用的函数。\n\n```js\n// 修改解析为调用 dom() 函数\n{\n  \"plugins\": [\n    [\"transform-react-jsx\", {\n      \"pragma\": \"dom\" // 默认 pragma 为 React.createElement\n    }]\n  ]\n}\n```\n\nbabel 将会把 JSX 中的标签名作为第一个参数，把 JSX 中的标签属性作为第二个参数，将标签内容作为剩余的参数。传递这些参数给 `pragma` 选项设置的函数。\n\n**PS: 为了方便起见，我们使用默认的解析为 React.createElement\\(\\)**\n\n### 实现 createElement\n\n`createElement()`接受至少 2 个参数：元素类型 type（字符串表示原生元素，函数表示自定义元素），元素设置 config。其他参数视为元素的子元素 children。并且该函数返回的是一个 `ReactElement` 对象，属性包括 type, props, key, ref。\n\n```js\n// element.js\nclass ReactElement {\n    constructor(type, props, key, ref) {\n        this.type = type\n        this.props = props\n        this.key = key\n        this.ref = ref\n    }\n}\n\nexport function createElement(type, config, ...children)｛\n    // ...\n    return new ReactElement(type, props, key, ref)\n｝\n```\n\n然后需要导出 `createElement`，才能够通过 `React.createElement()` 的方式调用。\n\n```js\n// index.js\nimport { createElement } from './element'\n\nconst React = {\n    createElement,\n}\n\nexport default React\n```\n\n`ReactElement`需要 props, key 与 ref 参数，这三个参数将通过处理 config 与 children 得到。\n\n我们将从 config 中获取 key 与 ref（若它们存在的话），并且根据 config 得到 props \\(去除一些不必要的属性\\)，同时将 children 添加到 props 当中。\n\n```js\nexport function createElement(type, config, ...children) {\n  let props = {}\n  let key = null\n  let ref = null\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref\n    // 当 key 为数字时，将 key 转换为字符串\n    key = config.key === undefined ? null : '' + config.key\n\n    for (let propsName in config) {\n      // 剔除一些不需要的属性（key, ref, __self, __source）\n      if (RESERVED_PROPS.hasOwnProperty(propsName)) {\n        continue\n      }\n\n      if (config.hasOwnProperty(propsName)) {\n        props[propsName] = config[propsName]\n      }\n    }\n\n    props.children = children\n  }\n\n  return new ReactElement(type, props, key, ref)\n}\n```\n\n除此之外，添加对 `defaultProps` 的支持。`defaultProps` 的使用方式如下：\n\n```js\n// App.js\nclass App extends Component {\n}\n\nApp.defaultProps = {\n    name: \"ahonn\"\n}\n```\n\n当传入 App 组件的 props 中不包含 name 时，设置默认的 name 为 \"ahonn\"。具体实现：当 ReactElement 的 type 属性为组件函数且包含 defaultProps 时遍历 props，若 props 中不包含  defaultProps 中的属性时，设置默认的 props。\n\n```js\nexport function createElement(type, config, ...children) {\n    // ...\n    if (type && type.defaultProps) {\n        let defaultProps = type.defaultProps\n        for (let propsName in defaultProps) {\n            if (props[propsName] === undefined) {\n                props[propsName] = defaultProps[propsName]\n            }\n        }\n    }\n}\n```\n\n目前为止完成了将 JSX 解析为函数调用（这部分由 babel 完成），调用 `React.createElement()` 生成 `ReactElement` 对象。\n\n接下来将实现 `instantiateReactComponent()`，通过 ReactELemnt 生成相对应的 `ReactComponent` 实例。\n\n### 实现工厂方法 instantiateReactComponent\n\n`instantiateReactComponent(element)`接受一个参数 element，该参数可以是 ReactElement 对象，string，number，false 或者 null。\n\n我们将只考虑 Web 端，而不像 React 一样使用适配器模式进行解耦。\n\nReactElement 生成相应 ReactComponent 实例的规则：\n\n* element 为 null 或 false 时，生成 ReactDOMEmptyComponent 对象实例\n\n* element 为 string 或者 number 时，生成 ReactDOMTextComponent 对象实例\n\n* element 为 object\n\n  * element.type 为 string 时，生成 ReactDOMComponent 对象实例\n\n  * element.type 为 function（组件函数）时，生成 ReactCompositeComponent 对象实例\n\n```js\n// virtual-dom.js\nexport function instantiateReactComponent(element) {\n  let instance = null\n  if (element === null || element === false) {\n    instance = new ReactDOMEmptyComponent()\n  }\n\n  if (typeof element === 'string' || typeof element === 'number') {\n    instance = new ReactDOMTextComponent(element)\n  }\n\n  if (typeof element === 'object') {\n    let type = element.type\n    if (typeof type === 'string') {\n      instance = new ReactDomComponent(element)\n    } else if (typeof type === 'function'){\n      instance = new ReactCompositeComponent(element)\n    }\n  }\n  return instance\n}\n```\n\n### 实现 ReactComponent\n\n现在，我们需要有不同的 `ReactComponent` 类以供 `instantiateReactComponent()`使用。同时需要实现每个类的 `mountComponent()` 方法来返回对应的 HTML 片段。\n\n**ReactDOMEmptyComponent**\n\n`ReactDOMEmptyComponent` 表示空组件， `mountComponent()` 方法返回空字符串。\n\n```js\nclass ReactDOMEmptyComponent {\n  constructor() {\n    this._element = null\n  }\n\n  mountComponent() {\n    return ''\n  }\n}\n```\n\n**ReactDOMTextComponent**\n\nReactDOMTextComponent 表示 DOM 文本组件，`mountComponent()`方法返回对应的字符串。\n\n```js\nclass ReactDOMTextComponent {\n  constructor(text) {\n    this._element = text\n    this._stringText = '' + text\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    return this._stringText\n  }\n}\n```\n\n**ReactDOMComponent**\n\nReactDOMComponent 表示原生组件，即浏览器支持的标签（div, p, h1, etc.）。`mountConponent()` 方法返回对应的 HTML 字符串。\n\n```js\nclass ReactDomComponent {\n  constructor(element) {\n    let tag = element.type\n\n    this._element = element\n    this._tag = tag.toLowerCase()\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    if (typeof this._element.type !== 'string') {\n      throw new Error('DOMComponent\\'s Element.type must be string')\n    }\n\n    let ret = `<${this._tag} `\n    let props = this._element.props\n    for (var propsName in props) {\n      if (propsName === 'children') {\n        continue\n      }\n      let propsValue = props[propsName]\n      ret += `${propsName}=${propsValue}`\n    }\n    ret += '>'\n\n    let tagContent = ''\n    if (props.children) {\n      tagContent = this._mountChildren(props.children)\n    }\n    ret += tagContent\n    ret += `</${this._tag}>`\n    return ret\n  }\n}\n```\n\n`ReactDOMComponent` 的 `mountComponent()`方法会相对复杂一点。具体实现思路是，通过 `ReactElement` 的 type 与 props 属性拼接对应的 HTML 标签。处理 props 的时候需要跳过 children 属性，因为需要将子组件放在当前组件中。\n\n当存在子组件（children）时，调用 `_mountChildren(children)`将组件转换为对应的 HTML 片段。具体过程是遍历 children，转换为 `ReactComponent` 并调用其 `mountComponent()` 方法。\n\n```js\n_mountChildren(children) {\n  let result = ''\n  for (let index in children) {\n    const child = children[index]\n    const childrenComponent = instantiateReactComponent(child)\n    result += childrenComponent.mountComponent(index)\n  }\n  return result\n}\n```\n\n**ReactCompositeComponent**\n\nReactCompositeComponent 表示自定义的组件，`mountComponent()`方法将根据提供的组件函数（element.type）实例化，并调用该组件的 `render()`方法返回 `ReactElement` 对象。再通过`instantiateReactComponent()` 生成对应的 `ReactComponent`，最后执行该 `ReactComponent` 的`mountComponent()`方法。\n\n```js\nclass ReactCompositeComponent {\n  constructor(element) {\n    this._element = element\n    this._rootId = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootId = rootID\n    if (typeof this._element.type !== 'function') {\n      throw new Error('CompositeComponent\\'s Element.type must be function')\n    }\n\n    const Component = this._element.type\n    const props = this._element.props\n    const instance = new Component(props)\n\n    const renderedElement = instance.render()\n    const renderedComponent = instantiateReactComponent(renderedElement)\n    const renderedResult = renderedComponent.mountComponent(rootID)\n    return renderedResult\n  }\n}\n```\n\n通过 ReactCompositeComponent 将之前的 ReactComponent 联系起来，并递归调用 `mountComponent`方法得到一段 HTML。最后 `render()`通过 node.innerHTML 将 HTML 字符串填到页面上对应的容器中。\n\n### 实现 render\n\n最后将之前的实现串起来，利用 innerHTML 将组件渲染到页面上。\n\n```js\nexport function render(element, container) {\n  const rootID = 0\n  const mainComponent = instantiateReactComponent(element)\n  const containerContent = mainComponent.mountComponent(rootID)\n\n  container.innerHTML = containerContent\n}\n```\n\n到这里就基本上简单的实现了 React 中将组件渲染到页面上的部分。可以通过一个简单的例子验证一下。\n\n```js\n// index.js\nimport React from './tiny-react'\nimport ReactDOM from './tiny-react'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// App.js\n\nimport React, { Component } from './tiny-react'\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <span>It is Work!</span>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n页面上将显示 It is Work!\n\n## 后记\n\n虽然没有涉及到组件更新与组件生命周期，通过阅读 React 的源码基本上也对初始化渲染的过程有了一定的了解，希望对你有所帮助。\n\n在此感谢 [preact](https://github.com/developit/preact), [react-lite](https://github.com/Lucifier129/react-lite), [react-tiny](https://github.com/CodeFalling/react-tiny) 等项目，它们为本文提供了很大帮助。\n\n文中的所有代码均于 [tiny-react init-render](https://github.com/ahonn/tiny-react/tree/init-render) ，感谢阅读。\n\n","timeToRead":9}},{"node":{"id":"74e39aee-e3d6-55ac-8677-a83f58ce0345","frontmatter":{"title":"Koa2 源码分析","date":"2017/05/17","tags":["Koa","Node.js"]},"fields":{"slug":"/posts/2017051740"},"excerpt":"源码结构 Koa 的源码中主要为   目录下的  、 、  与   文件 application.js : 框架入口，导出 Application 类，即使用时导入的 Koa 类 context.js : context 对象的原型，代理 request 与 response …","rawMarkdownBody":"\n## 源码结构\n\nKoa 的源码中主要为 `lib` 目录下的 `application.js`、`context.js`、`request.js` 与 `response.js` 文件\n\n<!--more-->\n\n```\n.\n├── AUTHORS\n├── CODE_OF_CONDUCT.md\n├── History.md\n├── LICENSE\n├── Makefile\n├── Readme.md\n├── benchmarks\n├── docs\n├── lib\n│   ├── application.js\n│   ├── context.js\n│   ├── request.js\n│   └── response.js\n├── package.json\n└── test\n```\n\n**application.js**: 框架入口，导出 Application 类，即使用时导入的 Koa 类\n\n**context.js**: context 对象的原型，代理 request 与 response 对象\n\n**request.js**:  request 对象的原型，提供请求相关的数据与操作\n\n**response.js**: response 对象的原型，提供响应相关的数据与操作\n\n## Application\n\napplication.js 是 Koa 框架的入口，导出 Application 类来用于创建 app 对象。\n\n```js\nconst Koa = require('koa'); // 导入 Koa, 即导入 Application 类\nconst app = new Koa(); // 创建 Application 类的实例\n```\n\nApplication 继承于 EventEmitter 类，使得 Koa 能够监听事件。\n\n## 构造函数\n\nApplication 类包含了以下属性：\n\n* **proxy**: 是否信任 proxy header 参数，默认为 false\n* **middleware**: 保存通过 `app.use(middleware)` 注册的中间件\n* **subdomainOffset**: 子域默认偏移量，默认为 2\n* **env**: 环境参数，默认为 NODE\\_ENV 或 'development'\n* **context**: context 模块，通过 `context.js` 创建\n* **request**: request 模块，通过 `request.js` 创建\n* **response**: response 模块，通过 `response.js` 创建\n\n## Application\\#listen\n\nKoa 通过 `app.listen(port)` 函数在某个端口启动服务。\n\nlisten 函数通过 http 模块开启服务：\n\n```js\n/**\n * Shorthand for:\n *\n *    http.createServer(app.callback()).listen(...)\n *\n * @param {Mixed} ...\n * @return {Server}\n * @api public\n */\n\nlisten(...args) {\n  debug('listen');\n  const server = http.createServer(this.callback());\n  return server.listen(...args);\n}\n```\n\n实际上 `app.listen()`为 `http.createServer(app.callback()).listen(...)`的速记写法。\n\n`http.createServer()`用于创建 Web 服务器，接受一个请求监听函数，并在得到请求时执行。\n\n`app.callback()`用于处理请求，合并中间件与创建请求上下文对象等。\n\n### Application\\#use\n\nKoa 通过 `app.use()`添加中间件，并将中间件储存在 `app.middleware`中。\n\n在执行 `app.callback()`时会将 `app.middleware` 中的中间件合并为一个函数。\n\n```js\n/**\n * Use the given middleware `fn`.\n *\n * Old-style middleware will be converted.\n *\n * @param {Function} fn\n * @return {Application} self\n * @api public\n */\n\nuse(fn) {\n  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n  if (isGeneratorFunction(fn)) {\n    deprecate('Support for generators will be removed in v3. ' +\n              'See the documentation for examples of how to convert old middleware ' +\n              'https://github.com/koajs/koa/blob/master/docs/migration.md');\n    fn = convert(fn);\n  }\n  debug('use %s', fn._name || fn.name || '-');\n  this.middleware.push(fn);\n  return this;\n}\n```\n\nKoa1.x 版本使用 Generator Function 的方式写中间件，而 Koa2 改用 ES6 async/await。\n\n所以在 `use()` 函数中会判断是否为旧风格的中间件写法，并对旧风格写法的中间件进行转换（使用 [koa-convert](https://github.com/koajs/convert) 进行转换）。\n\n可以注意到这里 `use()` 函数返回了 this，这使得在添加中间件的时候能够链式调用。\n\n```js\napp\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  // ...\n```\n\n### Application\\#callback\n\n`app.callback()`负责合并中间件，创建请求上下文对象以及返回请求处理函数等。\n\n```js\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listeners('error').length) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      res.statusCode = 404;\n      const ctx = this.createContext(req, res);\n      const onerror = err => ctx.onerror(err);\n      const handleResponse = () => respond(ctx);\n      onFinished(res, onerror);\n      return fn(ctx).then(handleResponse).catch(onerror);\n    };\n\n    return handleRequest;\n  }\n```\n\n通过 `compose` 函数（[koa-compose](https://github.com/koajs/compose)）合并 `app.middleware`中的所有中间件。[查看](/koa/compose.md)关于 koa-compose 的分析。\n\n`app.callback()` 函数最后返回一个请求处理函数 `handleRequest`。该函数即为`http.createServer` 接收的请求处理函数，在得到请求时执行。\n\n#### handleRequest\n\n`handleRequest`函数首先将响应状态码默认设置为 404，接着通过 `app.createContext()`创建请求的上下文对象。\n\n`onFinished(res, onerror)`通过第三方库 [on-finished](https://github.com/jshttp/on-finished) 监听 http response，当请求结束时执行回调。\n\n这里传入的回调是 `context.onerror(err)`，即当错误发生时才执行。\n\n最后返回 `fn(ctx).then(handleResponse).catch(onerror)`，即将所有中间件执行（传入请求上下文对象 ctx），之后执行响应处理函数（`app.respond(ctx)`），当抛出异常时同样使用 `cintext.onerror(err)`处理。\n\n#### createContext\n\napp.createContext\\(\\) 用来创建请求上下文对象，并代理 Koa 的 request 和 response 模块。\n\n```js\n/**\n * Initialize a new context.\n *\n * @api private\n */\n\ncreateContext(req, res) {\n  const context = Object.create(this.context);\n  const request = context.request = Object.create(this.request);\n  const response = context.response = Object.create(this.response);\n  context.app = request.app = response.app = this;\n  context.req = request.req = response.req = req;\n  context.res = request.res = response.res = res;\n  request.ctx = response.ctx = context;\n  request.response = response;\n  response.request = request;\n  context.originalUrl = request.originalUrl = req.url;\n  context.cookies = new Cookies(req, res, {\n    keys: this.keys,\n    secure: request.secure\n  });\n  request.ip = request.ips[0] || req.socket.remoteAddress || '';\n  context.accept = request.accept = accepts(req);\n  context.state = {};\n  return context;\n}\n```\n\n这里对请求都对应在上下文对象中添加对应的 cookies。\n\n#### respond\n\n`app.respond(ctx)` 函数，也就是 `app.createContext()`函数中的 `handleResponse`。在所有中间件执行完之后执行。\n\n在 koa 中可以通过设置 `ctx.respond = false`来跳过这个函数，但不推荐这样做。另外，当上下文对象不可写时也会退出该函数：\n\n```js\nif (false === ctx.respond) return;\n// ...\nif (!ctx.writable) return;\n```\n\n当返回的状态码表示没有响应主体时，将响应主体置空：\n\n```js\n// ignore body\nif (statuses.empty[code]) {\n  // strip headers\n  ctx.body = null;\n  return res.end();\n}\n```\n\n当请求方法为 HEAD 时，判断响应头是否发送以及响应主体是否为 JSON 格式，若满足则设置响应 Content-Length：\n\n```js\nif ('HEAD' == ctx.method) {\n  if (!res.headersSent && isJSON(body)) {\n    ctx.length = Buffer.byteLength(JSON.stringify(body));\n  }\n  return res.end();\n}\n```\n\n当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码。并当响应头未发送时设置 Content-Type 与 Content-Length：\n\n```js\nif (null == body) {\n  body = ctx.message || String(code);\n  if (!res.headersSent) {\n    ctx.type = 'text';\n    ctx.length = Buffer.byteLength(body);\n  }\n  return res.end(body);\n}\n```\n\n最后，对不同的响应主体进行处理：\n\n```js\n// responses\nif (Buffer.isBuffer(body)) return res.end(body);\nif ('string' == typeof body) return res.end(body);\nif (body instanceof Stream) return body.pipe(res);\n\n// body: json\nbody = JSON.stringify(body);\nif (!res.headersSent) {\n  ctx.length = Buffer.byteLength(body);\n}\nres.end(body);\n```\n\n## Compose\n\n在 application.js 中，`callback()`函数通过 `koa-compose` 组合所有的中间件，组合成单个函数。\n\nkoa-compose  的实现很简单：\n\n```js\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n首先判断了传入得中间件参数是否为数组，并检查且数组的元素是否为函数，然后返回了一个将中间件组合起来的函数。\n\n重点关注返回的函数中的`dispatch(i)`函数，这个函数将获取第一个中间件，并在返回的 Promise 中执行。当中间件`await next()`时执行下一个中间件，即 `dispatch(i + 1)`。\n\n执行流程可以简单看作：\n\n```js\nasync function middleware1() {\n    console.log('middleware1 begin');\n    await middleware2();\n    console.log('middleware1 end');\n}\n\nasync function middleware2() {\n    console.log('middleware2 begin');\n    await middleware3();\n    console.log('middleware2 end');\n}\n\nfunction middleware3() {\n    console.log('middleware3 begin');\n    console.log('middleware3 end');\n}\n\nmiddleware1();\n// 执行结果\nmiddleware1 begin\nmiddleware2 begin\nmiddleware3 begin\nmiddleware3 end\nmiddleware2 end\nmiddleware1 end\n```\n\n`compose()` 函数通过 Promise 将这个过程串联起来，从而返回单个中间件函数。\n\n## Context\n\nKoa 中的 Context 模块封装了 request 与 response，代理了这两个对象的方法与属性。\n\n其中使用了 Tj 写的 [node-delegates](https://github.com/tj/node-delegates) 库，用于代理 context.request 与 context.response 上的方法与属性。\n\n```js\n/**\n * Response delegation.\n */\n\ndelegate(proto, 'response')\n  .method('attachment')\n  .method('redirect')\n  .method('remove')\n  .method('vary')\n  .method('set')\n  .method('append')\n  .method('flushHeaders')\n  .access('status')\n  .access('message')\n  .access('body')\n  .access('length')\n  .access('type')\n  .access('lastModified')\n  .access('etag')\n  .getter('headerSent')\n  .getter('writable');\n  // ...\n```\n\ncontext 除了代理这两个模块之外，还包含了一个请求异常时的错误处理函数。\n\n在 application.js 的 `callback()`使用到这个函数。\n\n```js\nconst onerror = err => ctx.onerror(err);\nconst handleResponse = () => respond(ctx);\nonFinished(res, onerror);\nreturn fn(ctx).then(handleResponse).catch(onerror);\n```\n\n### Context\\#onerror\n\n`context.onerror(err)`首先对传入的 err 变量进行判断，当 err 为空时退出该函数，或者当 err 不为空且不为 Error 类型时抛出异常。\n\n```js\n if (null == err) return;\n\n if (!(err instanceof Error)) err = new Error(`non-error thrown: ${err}`);\n```\n\n接着触发 app 自身的 error 事件，将错误抛给 app。\n\n在此之前，设置 `headerSent`变量表示响应头是否发送，若响应头以发送，或者不可写（即无法在响应中添加错误信息等），则退出该函数。\n\n```js\nlet headerSent = false;\nif (this.headerSent || !this.writable) {\n  headerSent = err.headerSent = true;\n}\n\n// delegate\nthis.app.emit('error', err, this);\n\n// nothing we can do here other\n// than delegate to the app-level\n// handler and log.\nif (headerSent) {\n   return;\n}\n```\n\n因为发生了错误，所以必须将之前的中间设置的响应头信息清空。\n\n这里使用了 Node 提供的 [http.ServerResponse](https://nodejs.org/api/http.html#http_class_http_serverresponse) 类上的 `getHeaderNames()` 与 `removeHeader()` 方法。但`getHeaderNames()`\n\n这个函数是在 Node.js 7.7 时加入的，所以当没有提供该方法时需要使用 `_header`来清空响应头。详情可见: [Node.js \\#10805。](https://github.com/nodejs/node/pull/10805)\n\n```js\n// first unset all headers\nif (typeof res.getHeaderNames === 'function') {\n  res.getHeaderNames().forEach(name => res.removeHeader(name));\n} else {\n  res._headers = {}; // Node < 7.7\n}\n```\n\n清空之前的中间件设置的响应头之后，将响应头设置为 `err.headers`，并设置 Context-Type 与状态码。\n\n当错误码为 ENOENT 时，意味着找不到该资源，将状态码设置为 404；当没有状态码或状体啊码错误时默认设置为 500。\n\n```js\n// then set those specified\nthis.set(err.headers);\n\n// force text/plain\nthis.type = 'text';\n\n// ENOENT support\nif ('ENOENT' == err.code) err.status = 404;\n\n// default to 500\nif ('number' != typeof err.status || !statuses[err.status]) err.status = 500;\n```\n\n最后当抛出的错误为自定义错误时，返回错误信息。\n\nKoa 使用 [http-errors](https://github.com/jshttp/http-errors) 创建错误对象，`expose` 属性表示是否像客户端暴露错误信息。\n\n```js\nconst code = statuses[err.status];\nconst msg = err.expose ? err.message : code;\nthis.status = err.status;\nthis.length = Buffer.byteLength(msg);\nthis.res.end(msg);\n```\n\n## Request\n\nRequest 模块封装了请求相关的属性以及方法。通过 application 中的 `createContext()` 方法，代理对应的 request 对象。\n\n```js\nconst request = context.request = Object.create(this.request);\n// ...\ncontext.req = request.req = response.req = req;\n// ...\nrequest.response = response;\n```\n\n`request.req`为原生的请求对象，在 Request 模块中属性的获取都是通过 `ths.req` 来获取的（即 `request.req`）。\n\n## Response\n\nResponse 模块封装了响应相关的属性以及方法。与 request 相同，通过`createContext()` 方法代理对应的 response 对象。\n\n```js\nconst response = context.response = Object.create(this.response);\n// ...\ncontext.res = request.res = response.res = res;\n// ...\nresponse.request = request;\n```\n","timeToRead":7}},{"node":{"id":"b5634de1-7299-56b8-a79b-71330d3d042a","frontmatter":{"title":"转投 Neovim","date":"2017/03/27","tags":["Vim"]},"fields":{"slug":"/posts/2017032739"},"excerpt":"很久之前就听说过 Neovim，但一直没有怎么了解过。昨天下午折腾了一下，彻底转投 Neovim 了。 虽然说这两货的差别目前还不是很大，但是 Neovim 实现了嵌入式终端模拟器，Excited! 各种 REPL 插件统统都可以卸载了！ 迁移配置文件 Neovim 配置完全兼…","rawMarkdownBody":"\n很久之前就听说过 Neovim，但一直没有怎么了解过。昨天下午折腾了一下，彻底转投 Neovim 了。\n\n虽然说这两货的差别目前还不是很大，但是 Neovim 实现了嵌入式终端模拟器，Excited! 各种 REPL 插件统统都可以卸载了！\n\n<!--more-->\n\n## 迁移配置文件\nNeovim 配置完全兼容原来的 `.vimrc`，只需要：\n\n``` bash\nmkdir -p ${XDG_CONFIG_HOME:=$HOME/.config}\nln -s ~/.vim $XDG_CONFIG_HOME/nvim\nln -s ~/.vimrc $XDG_CONFIG_HOME/nvim/init.vim\n```\n\n## 使用 ale 代替 syntastic\n老早就觉得 `syntastic` 同步检查代码好难用，这下换成 `ale` 舒服多了。有之前使用 atom 时自带的代码检查的感觉。\n\n(Vim 8 好像也已经提供了异步 API，但是我等到换成 Neovim 才知道..)\n\n## 把 Leader 改成空格\n其实是看了 [Vim 高效率配置导论](https://zhuanlan.zhihu.com/p/25905625) 这篇文章之后试着改的，改完发现空格比起原先的 `,` 好用多了。让大拇指动了起来。\n\n然后切换 buffter 的快捷键就映射成了 `<Space> + n/m`，简直不要太顺手。\n\n## 使用 Spacegray 主题\n之前使用的 `molokai` 看久了有点视觉疲劳，发现之前在用 `sublime text` 时使用的 `Spacegray` 也有 Vim 版本，果断换之。（折腾高亮主题是永恒的.. ）\n\n## 优化难用的缩进调整\n在 Visual 模式下调整缩进很不好用，`v>` 之后又得重新选中，虽然说可以 `v3>` 之类的，但是需要去计算多少个缩进，看起来并不是很明显。\n\n遂，添加了下面这两个 mapping：\n\n```\nvnoremap < <v\nvnoremap > >v\n```\n\n这样映射之后我就可以 `v>>>` 去缩进了，好用到不行！\n\n## Vim 使用总结\n使用 Vim 也差不多一个来月了，越来越发现 Vim 的便利之处，虽然说折腾配置插件花的时间会久一点。但是折腾完之后效率提高还是蛮多的，以至于现在在别的编辑器里下意识的用 Vim 模式，发现没有之后用方向键或者鼠标去移动都觉得超级慢。\n\n开始理解 Vim 学习路线那张图表的意思了～\n\n> 我的 Vim 配置：[vimrc](https://github.com/ahonn/vimrc)\n\n\n","timeToRead":1}},{"node":{"id":"b35954e7-ff1d-51b6-a981-baf36edfc8d3","frontmatter":{"title":"阿里巴巴暑假实习面试总结","date":"2017/03/16","tags":["前端","面试"]},"fields":{"slug":"/posts/2017031638"},"excerpt":"2月末的时候，通过  simplyY  内推了阿里巴巴暑期实习的前端开发岗，在此表示感谢。\n接着3月1号收到了内推的通知邮件，完善信息后很快就接到了一面的电话（3月3号）。 一面 面试了大概20分钟左右，整体内容还是比较偏基础。一开始是正常流程的自我介绍，说是三分钟自我介绍，但…","rawMarkdownBody":"\n2月末的时候，通过 [simplyY](https://simplyy.space/) 内推了阿里巴巴暑期实习的前端开发岗，在此表示感谢。\n接着3月1号收到了内推的通知邮件，完善信息后很快就接到了一面的电话（3月3号）。\n\n## 一面\n面试了大概20分钟左右，整体内容还是比较偏基础。一开始是正常流程的自我介绍，说是三分钟自我介绍，但是我语速比较快的不到两分钟的介绍完了。(刚好是临近中午，原本打算吃饭的，要是去吃饭的话就得在路上面了...）\n\n### CSS 垂直居中\n这个写过一篇博文专门总结过，不过面试的时候还是太过紧张没有答全。主要是 Flexbox 布局的垂直居中比较容易忘记。\n\n具体就不再啰嗦了，详情可以查看：[CSS 实现垂直居中](http://www.ahonn.me/2016/06/29/vertical-center-for-css/)\n\n<!--more-->\n\n### call 与 apply 的区别，以及性能差别\n`call` 与 `apply` 的区别，这是一个老生常谈的面试题了。`call()` 与 `apply()` 都是用于在指定 this 值与参数的情况下调用函数，主要的区别在于除了传入 this 值之外，`apply()` 接收类数组或者类数组对象来作为调用的函数的参数，而 `call()` 则是需要分别传入函数的每一个参数（除第一个参数之外的其他参数）。\n\n> call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。—— 『JavaScript 高级程序设计』\n\n区别的话基本上只要看过书或者刷过面试题都会知道，但 `call()` 与 `apply()` 之间的性能差别就不是那么常见了。\n比较幸运的是，之前在阅读 underscore 源码的时候有注意到这个细节，为此也写过另外的文章：[从 optimizeCb 说起](http://www.ahonn.me/2016/05/03/starting-from-the-optimizeCb/)。\n\n实践证明，在知道调用函数的参数数量时，使用 `call()` 的性能会优于 `apply()`。主要在实现的过程中 `apply()` 需要完成额外的操作（判断第二个参数类数组的长度，etc.）。具体为什么有这种差别，可以在 ECMAScript Language Specification 中查看 [Function.prototype.apply](https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.3) 与 [Function.prototype.call](https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.4) 的具体实现差异。\n\n**参考链接**\n\n- [javascript - What is the difference between call and apply? - Stack Overflow](http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply)\n- [javascript - Why is call so much faster than apply? - Stack Overflow](http://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply)\n- [call vs apply · jsPerf](https://jsperf.com/call-apply-segu)\n\n### 什么是闭包\n又是一个老生常谈的问题。我的理解比较肤浅，就是 A 函数返回 B 函数，B 函数能够访问 A 函数中的局部变量，使得在 A 外部的作用域中能够使用 B 函数间接操作 A 函数中的局部变量，这样就形成了一个闭包。A 函数中的局部变量与返回的 B 函数一同存在，不会被垃圾回收机制清理（引用还存在）。\n\n> 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。—— 维基百科\n\n建议阅读 [『你不知道的 JavaScript（上卷）』](https://book.douban.com/subject/26351021/) 中有关作用域与闭包的部分。\n\n### 什么是尾递归\n\n> 在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。—— 维基百科\n\n一般递归实现阶乘：\n``` js\nfunction fact(n) {\n  if (n == 0 || n == 1) {\n    return 1;\n  } else {\n    return n * fact(n - 1);\n  }\n}\n```\n\n一般递归需要中栈上维护函数的调用信息直到函数返回后才释放，容易发生『栈溢出』错误。但对于尾递归来说，只需要维护一个调用记录。\n\n尾递归实现阶乘：\n``` js\nfunction fact(n) {\n  return fact-iter(n, 1);\n}\n\nfunction fact-iter(n, a) {\n  if (n == 0) {\n    return 1;\n  } else if (n == 1) {\n    return a;\n  } else {\n    return fact-iter(n - 1, n * a);\n  }\n}\n```\n\n关于递归与尾递归，在 [『计算机程序的构造和解释』](https://book.douban.com/subject/1148282/)中也有类似的讨论。\n\n### React 的设计理念\n这部分答得不是很好，只提到了组件化，单向数据流，Virtual DOM 之类的。\n\n有关 React 的设计思想可以参考这一篇文章：[React 设计思想](https://github.com/react-guide/react-basic)。\n\n### 前端安全（攻击方式与如何防范）\n\n第一反应就是 `XSS` 与 `CSRF`，`XSS` 可以通过对输入数据进行转义来防范，而 `CSRF` 则通过使用 SSL 链接访问资源或者请求中添加验证码来进行防范。\n\n除此之外我漏掉了网络劫持，控制台注入代码等攻击方式，这里有篇文章做了详细介绍：[聊一聊WEB前端安全那些事儿](https://segmentfault.com/a/1190000006672214)。\n\n## 二面\n第一次远程视频面试，好紧张。\n\n一开始问了 CSS 中 position 属性的 absolute 的作用以及应用场景，这个基本上没有什么问题。接着叫我拿纸写冒泡排序（手写 T-T），飞快的写完。\n然后跟一面一样也问了前端安全相关的问题，一下子都不紧张了.. 没有想象中的难。\n\n### 实现 bind 函数\n同样是让我写代码，同样是手写（T-T）。这个问题对我来说不算难，不过只是写了简单的实现，没有考虑其他情况。\n\n``` js\nFunction.prototype.bind = Function.prototype.bind || function (context) {\n  var self = this;\n  return function () {\n    return self.apply(context, arguments);\n  }\n}\n```\n\n基本原理就是使用 `apply()` 与闭包，返回包含 `apply()` 的闭包使得 `apply()` 绑定指定作用域，但并未执行。\n\n### 阅读 Underscore 源码的经历\n之前拖拖拉拉的阅读完了 Underscore 的源码，并提交了一个小 [Pull Request](https://github.com/jashkenas/underscore/pull/2630)。\n\n在阅读的过程中学到了许多的东西，例如上面提到的 call 与 apply 的性能差别，除此之外还有如何去判断变量的类型，以及如何判断两个变量是否相等，等等。另外也了解到许多闭包的使用场景。\n\n### 阅读其他类库的收获\n除了 Underscore 之外还阅读过一点 Bootstrap 和 jQuery，这个博客主题的样式部分的组织方式就是参考了 Bootstrap 的组织方式，另外也稍微阅读过 jQuery中 `$.ajax` 以及事件相关的源码。\n\n在阅读代码的过程中的收获就是学习了一些组织代码的方式，还有如何写才能有利于拓展，更加健壮。其中也学到了一些提高性能的技巧，函数缓存，事件队列之类的。\n\n### 博客主题的开发经历\n其实一开始写主题只是想给自己用，之后发现蛮多人也喜欢我这个主题的，并时不时有人中 Github 上提 Issue，这对我是莫大的鼓励。虽然我水平并不是很高，但是写出来的东西有人用感觉真的是特别开心，也特别有动力去改进。\n\n从开始去写主题到现在差不多也一年了，这一年中我从前端小白变成前端大白。在维护的过程中学习到很多东西，虽然目前写得也不是很好，但是我还是会慢慢改进继续维护下去的。\n\n维护的过程中的收获就是，当站在自己的角度看问题与在别人的角度看完全是不一样的，或许有个功能我并不需要，但是有人提了，我就得站在『用户』的角度去思考，去实现。『用户』只关心能不能用，好不好用，而并不关心代码写得怎么样。\n\n### 实习期间遇到得难题\n可能我做的工作相对简单，就算不会，基本上靠搜索引擎都能够解决。**我觉得能用 Google 解决的问题不算难题。**以我现在的水平，还达不到遇到的难题 Google 搜索不到的😹\n\n## 三面\n三面基本上没有问太过具体的前端相关的问题，大部分是在聊聊看法，聊聊项目。\n\n开始让我用纸画出博客的设计，其实主要还是主题，没什么难度，毕竟代码都是我自己写的。\n\n然后让我介绍一下我熟悉的一个框架，说的 React，提及到了 Vitrual DOM 和 diff 算法，说了一下 diff 算法的大概策略。还有说到组件化，单向数据流等等。幸运的是，我在二面之前刷了 『深入 React 技术栈』这本书，结合之前的实践能够说个大概。\n\n中间有聊到兴趣爱好，我想了想好像只有写代码。听歌应该也算？写代码的时候必定要听歌。我记得去年国庆有一天从起床写到晚上睡觉，差不多写了 11 个小时，那时候正在折腾 React 与 Meteor。我自己都觉得不可思议。\n\n## 总结\n可能是运气问题，我觉得我的这几面难度都不高😹。得益于看的书，好多知识点都是书上有的。基本上基础的前端面试题都可以在红宝书上找到，真不愧为前端面试宝典。另外 Github 上的这个博客主题也帮了很大的忙，300+ star 果然还是有点用处的（虽然说 star 不能代表什么，而且的确写得也很水，但作用不可否认）。\n\n最后，基础很重要，基础扎实是基本。但是如果想要有突出的表现还是需要更有深度的研究。需要经常思考总结，不仅仅是浮于表面，更要深入原理。\n\n","timeToRead":5}},{"node":{"id":"f9cbccc0-0b7d-55dc-bf3c-3fc90099762c","frontmatter":{"title":"答前端面试题","date":"2017/03/11","tags":["前端","面试"]},"fields":{"slug":"/posts/2017031137"},"excerpt":"答  中级前端工程师面试 我想问的几个问题  中的几个问题，感谢  @SimplyY\n 我最大的优势以及为什么选择前端 我最大的优势是自学能力与理解能力强，并且不给自己套上『我是前端程序员』的枷锁，对于所有技术保持好奇心，不畏惧舒适圈外的事物并敢于尝试。 选择前端的理由是，前端…","rawMarkdownBody":"\n> 答 [中级前端工程师面试 我想问的几个问题](https://zhuanlan.zhihu.com/p/25701897) 中的几个问题，感谢 [@SimplyY\n](https://www.zhihu.com/people/simplyy/answers)\n\n## 我最大的优势以及为什么选择前端\n\n- 我最大的优势是自学能力与理解能力强，并且不给自己套上『我是前端程序员』的枷锁，对于所有技术保持好奇心，不畏惧舒适圈外的事物并敢于尝试。\n- 选择前端的理由是，前端能够迅速的把想法实现，可选技术栈广泛（Web，移动端，桌面客户端），也是前端的优点之一。\n\n<!--more-->\n\n## 前后端分离的原理及意义\n后端提供数据接口，前端获取数据并呈现。\n### 前后端分离的意义\n- 后端无须套模版，前后端解耦。\n- 提高工作效率，前后端同步开发。\n\n## 对 react 的理解与相对于 jQuery 开发的优势\n### 对 React 的理解\n  - 通过 Virtual DOM 和 Diff 算法隔离 DOM 操作。\n  - 采用单向数据流，数据流动方向单一，可跟踪。\n  - 组件化，JSX 自定义标签，便于抽象化。\n\n### 对比 jQuery 开发的优势\n- 无需直接操作 DOM，事件通过改变 state 间接操作 DOM。\n\n![React-vs-jQuery.png](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/lw0qj.jpg)\n\n\n## 页面性能优化\n> **页面生成过程**\n\n>  - HTML代码转化为DOM\n>  - CSS代码转化成CSSOM\n>  - 结合DOM和CSSOM，生成一棵渲染树\n>  - 生成布局（layout），即将所有渲染树的所有节点进行平面合成\n>  - 将布局绘制（paint）在屏幕上\n\n- 减少 HTTP 请求（合并 CSS/JS，小于 10k 的图片 base64）\n- 减少 DOM 操作（可使用 DocumentFragment）\n- 避免不必要的重绘与重排（重排必定导致重绘）\n- 优化 CSS 选择器（从右向左匹配）\n- CSS/JS minify，减少文件体积\n- 开启 Gzip 压缩\n- 将 CSS 放到顶部，JavaScript 放到尾部（JavaScript 会阻塞页面）\n- 压缩图片以及使用 CSS Sprite\n- 使用 CDN 加速，适当进行文件缓存\n- 合理控制 cookie 大小（每次请求都会包含 cookie）\n\n\n","timeToRead":2}},{"node":{"id":"4033317b-bfa5-562c-9869-0f23771a91d2","frontmatter":{"title":"XMLHttpRequest 学习笔记","date":"2017/03/02","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2017030236"},"excerpt":"AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。 Ajax 技术的核心是   对象，起初 IE 首先引入这个特性，后面其他浏览器供应商也提供了相同的实现。 X…","rawMarkdownBody":"\n> AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。\n\nAjax 技术的核心是 `XMLHttpRequest` 对象，起初 IE 首先引入这个特性，后面其他浏览器供应商也提供了相同的实现。\n\n## XMLHttpRequest 对象\n\nXMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。\n\n<!--more-->\n\n### 主要方法\n\n- open() 启动请求以备发送，参数包括请求方式，请求地址，是否异步\n\n- send() 发送请求，必要参数可发送请求主体数据，无数据时传入 null\n\n- abort() 发起异步请求时，终止请求\n\n- setRequestHeader() 设置请求头部信息\n\n- getRequestHeader() 获取请求头部信息\n\n- getAllRequestHeader() 获取全部请求头部信息，以字符串的形式返回\n\n### 主要属性\n\n- status 响应的 HTTP 状态码\n\n- statusText 响应的 HTTP 状态说明\n\n- responseText 作为响应主体返回的文本\n\n- responseXML 响应数据中的 XML DOM 文档\n\n- readyState 请求/响应过程的当前活动阶段\n\n - 0 未初始化，没有使用 `open()`\n\n - 1 启动，调用 `open()` 但未调用 `send()`\n\n - 2 发送，已经调用 `send()`，但未接收到响应数据\n\n - 3 接收，接收到部分响应数据\n\n - 4 完成，接收到全部响应数据\n\n### readystatechange 事件\n\n当 readyState 属性值改变时触发 readystatechange 事件。通过判断 readystate 属性的值，在完成请求响应整个过程之后执行某些操作。\n","timeToRead":1}},{"node":{"id":"562d54fe-04aa-5f5c-b982-995602ce9c2c","frontmatter":{"title":"Vim 折腾记","date":"2017/02/19","tags":["Vim"]},"fields":{"slug":"/posts/2017021935"},"excerpt":"昨天在微信读书上面看到了池建强的《MacTalk 人生元编程》，然后花了差不多一天看完，其中有篇有关于 Vim 的文章提起了我对这个编辑器的再一次兴趣（对的，我对它感兴趣很多次了，每次都懒..）。 一直懒得去慢慢配置它，又不想用别人的配置。自己用的编辑器还是想自己折腾，然后今天…","rawMarkdownBody":"\n昨天在微信读书上面看到了池建强的《MacTalk 人生元编程》，然后花了差不多一天看完，其中有篇有关于 Vim 的文章提起了我对这个编辑器的再一次兴趣（对的，我对它感兴趣很多次了，每次都懒..）。\n\n一直懒得去慢慢配置它，又不想用别人的配置。自己用的编辑器还是想自己折腾，然后今天就趁着我对这个还有点热度赶紧折腾起来。\n\n## MacVim\n其实在命令行里面直接写代码还有有些不习惯的，所以选了 MacVim 这个 GUI 版本。这样又可以与其他编辑器一样单独打开，想小改代码的时候又可以直接打开命令行搞。\n\n在 MacTalk 的文章里面有提到 Vim 中文版本的[帮助文档](http://sourceforge.net/projects/vimcdoc/files/latest/download)，遂下载之。果然还是中文的比较浅显易懂。\n\n以前看别人的 `.vimrc` 配置，里面有些编辑器的基本配置，也不知道是哪里查的。原来这些配置可以在编辑器中输入 `:help options` 进行查看。\n\n<!--more-->\n\n### 缩进\n关于缩进的配置，主要设置了 `autoindent`, `smartindent` 和 `expandtab` 这三个选项。\n\n- `autoindent` 选项根据上一行决定新行的缩进\n- `smartindent` 选项智能自动缩进\n- `expandtab` 选项将 tab 转换为空格\n\n```\nset autoindent\nset smartindent\nset expandtab\n```\n\n### 行号\n显示行号是硬需求，但是与其他编辑器不同，在 vim 上还有相对行号。\n\n```\nset number\nset relativenumber\n```\n\n## 插件\n显而易见，手动安装 vim 插件是很麻烦很麻烦的。与 sublime text 之类的类似，vim 同样有类似的插件管理器 [Vundle](https://github.com/VundleVim/Vundle.vim)。\n\n创建文件夹 `~/.vim` 和配置文件 `~/.vimrc`，并安装 Vundle:\n\n``` bash\n$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle\n```\n\n为了方便管理再新建一个 `.vimrc.bundles` 来单独存放插件列表：\n\n```\nset nocompatible    \" be iMproved, required\nfiletype off        \" requried\nset rtp+=~/.vim/bundle/vundle/\n\ncall vundle#begin()\n\n\" Let Vundle manage Vundle\nBundle 'gmarik/vundle'\n\n\" .... 其他插件\n\ncall vundle#end()\n\" required\nfiletype plugin indent on\n```\n\n以后添加插件的时候只需要在这个文件里面添加一行：\n\n```\nBundle 'xxx'\n```\n\n安装插件输入 `:BundleInstall` 命令即可，卸载插件时删除对应的配置并运行 `:BundleClean` 删除插件。\n\n### 括号补全\n第一次用的时候，输入 `(` 居然没有自己蹦出来另外一个 `)`。这不科学，讲道理这个是一定要的。\n\n发现很多人用的是 [delimitMate](https://github.com/Raimondi/delimitMate) ，添加 `Bundle 'delimitMate'` 到 `.vimrc.bundles`，运行 `BundleInstall`。\n\n安装完直接就可以自动补全括号了。\n\n### Emmet\n很多浏览器都支持 Emmet 插件，vim 同样也有。但这个 Emmet 是第三方的，叫 [Emmet.vim](https://github.com/mattn/emmet-vim/)。\n\n安装完之后主要是设置一下出发的快捷键，默认的快捷键是 `Ctrl + y`。\n我把快捷键修改成 `Ctrl + e` 比较顺手。\n\n```\n\" Emmet.vim\nlet g:user_emmet_expandabbr_key = '<c-e>'\n```\n\n### 目录树\n目录树就基本上也就是使用 [NERDTree](https://github.com/scrooloose/nerdtree)。\n\n开启目录树的快捷键修改为 `Ctrl + b`，然后当 vim 只剩目录树显示的时候自动退出。\n```\n\" NERDTree\nmap <c-b> :NERDTreeToggle<CR>\nautocmd vimenter * NERDTree\nautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTreeType\") &&b:NERDTreeType == \"primary\") | q | endif\n```\n\n### 代码补全\n补全用的就是大名鼎鼎的 [YouCompleteMe](https://github.com/Valloric/YouCompleteMe) 了。\n\n关于这个插件网上有很多插件，我就不啰嗦了。这里主要是抄的百度 EFE 的配置：\n\n```\n\" YouCompleteMe\n\" http://efe.baidu.com/blog/vim-javascript-completion/#youcompleteme\nlet g:ycm_min_num_of_chars_for_completion = 3\nlet g:ycm_autoclose_preview_window_after_completion=1\nlet g:ycm_complete_in_comments = 1\nlet g:ycm_key_list_select_completion = ['<c-n>', '<Down>']\nlet g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']\n\" Use tab\nfunction! TabFunction ()\n    let line = getline('.')\n    let substr = strpart(line, -1, col('.')+1)\n    let substr = matchstr(substr, \"[^ \\t]*$\")\n    if strlen(substr) == 0\n        return \"\\<tab>\"\n    endif\n    return pumvisible() ? \"\\<c-n>\" : \"\\<c-x>\\<c-o>\"\nendfunction\ninoremap <tab> <c-r>=TabFunction()<cr>\n\nlet g:ycm_semantic_triggers = {\n    \\   'css': [ 're!^\\s{2}', 're!:\\s+'],\n    \\   'html': [ '</' ],\n    \\ }\n\n```\n\n## 总结\n折腾了一下午，终于算是搞定了。其实过程还是蛮好玩的，有机会还想写写插件玩玩。抛弃 VS Code，开始 Vim 之旅感。\n","timeToRead":3}},{"node":{"id":"549c732d-864d-5bd0-9832-c73870cbd285","frontmatter":{"title":"JavaScript 继承的那些事","date":"2017/01/24","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2017012434"},"excerpt":"众所周知，JavaScript 的继承是实现继承，而没有 Java 中的接口继承。这是因为 JavaScript 中函数没有签名，而实现继承依靠的是原型链来实现的。 原型链继承 JavaScript 中通过修改对象原型指向的对象来实现继承，即是将一个对象的原型指向要继承的对象实…","rawMarkdownBody":"\n众所周知，JavaScript 的继承是实现继承，而没有 Java 中的接口继承。这是因为 JavaScript 中函数没有签名，而实现继承依靠的是原型链来实现的。\n\n## 原型链继承\n\nJavaScript 中通过修改对象原型指向的对象来实现继承，即是将一个对象的原型指向要继承的对象实例，从而实现继承对象的属性及方法。\n\n<!--more-->\n\n``` js\nfunction SuperType() {\n  this.type = 'super';\n}\n\nSuperType.prototype.getType() {\n  return this.type;\n}\n\nfunction SubType() {\n  this.type = 'sub';\n}\n\nSubType.prototype = new SuperType();\n\nvar sub = new SubType();\nconsole.log(sub.getType()); // \"sub\"\n```\n\n### 原型链继承的不足\n实际上，上面的代码还缺少一句代码，我们将 SubType 的原型指向了 SuperType 的实例，即`SubType.prototype.constructor` 会返回 `SuperType` 而不是 `SubType`，使用 `instanceof` 操作符返回的将是 `SuperType`。所以需要将 `SubType.prototype.constructor` 重新指向 `SubType`。\n\n``` js\n// ...\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\n// ...\n```\n\n但即使是这样，原型链继承依然有两点问题：原型中的实例引用类型属性会在所有对象实例中共享，无法想 Java 的继承一样向父类的构造函数中传递参数。\n\n## 其他继承方式\n\n由于原型链继承存在一些不足，为了解决这些不足，JavaScript 中还有其他的几种继承的方式。\n\n### 借用构造函数\n因为原型链无法传递参数到父类的构造函数中，因此出现了这种叫做借用构造函数的技术。顾名思义，即是借用父类的构造函数在子类中进行调用。\n\n``` js\nfunction SuperType() {\n  // ...\n}\n\nfunction SubType() {\n  SuperType.call(this); // <- 执行父类构造函数\n  // ...\n}\n```\n\n借用构造函数虽然解决了构造函数传参的问题，但是当父类拥有方法时每个子类的实例都会拥有独立的方法，这个问题与单独使用构造函数模式定义类型的时候相同。\n\n### 组合继承\n类比使用构造函数模式定义类型时的解决方法（组合构造函数模式与原型模式），继承时的解决方法也类似。即组合原型链继承和借用构造函数，属性由借用构造函数的方式继承，方法由原型链继承。\n\n实际上也就是在原型链继承的代码中添加在子类的构造函数中调用父类构造函数。\n\n``` js\nfunction SuperType() {\n  this.type = 'super';\n}\n\nSuperType.prototype.getType() {\n  return this.type;\n}\n\nfunction SubType() {\n  SuperType.call(this);\n  this.type = 'sub';\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\n```\n\n### 寄生组合式继承\n组合继承是常用的继承方式，但是同样的也是有不足之处：调用了两次父类的构造函数，一次在子类构造函数中调用父类构造函数，一次在实例父类对象赋值给子类的原型。\n\n寄生组合式继承在指定子类的原型的时候不必调用父类的构造函数，而是直接使用 `Object.create()` 创建父类原型的副本。\n\n``` js\nfunction SuperType() {\n  // ...\n}\n\nfunction SubType() {\n  SuperType.call(this);\n  // ...\n}\n\nSubType.prototype = Object.create(SuperType.prototype); // 直接使用父类原型创建副本\nSubType.prototype.constructor = SubType;\n```\n\n## ES6 中的继承\n\nES6 引入了 `class` 关键子，可以像其他语言中一样使用 `extends` 关键字来继承。虽然能够使用 `extends` 实现继承，但实际上内部还是基于原型。\n\n``` js\nclass SubType extends SuperType {\n  constructor() {\n    super();\n    // ...\n  }\n\n  // ...\n}\n```\n","timeToRead":2}},{"node":{"id":"e967b069-498e-5bde-a9e4-4dd8258dc68f","frontmatter":{"title":"从零开始制作 Hexo 主题","date":"2016/12/15","tags":["Hexo","前端"]},"fields":{"slug":"/posts/2016121533"},"excerpt":"写在前面 本文将会从零开始开发一个简单的博客主题。样式主要参考  Hexo theme  中的  Noise  主题。 开始之前你需要了解： 模板引擎 CSS预处理器 Hexo 文档 本文使用的模板引擎为  ejs ，使用的 CSS 预处理器为  stylus 。这也是 hex…","rawMarkdownBody":"## 写在前面\n本文将会从零开始开发一个简单的博客主题。样式主要参考 [Hexo theme](https://hexo.io/themes/) 中的 [Noise](https://github.com/lotabout/hexo-theme-noise) 主题。\n\n开始之前你需要了解：\n- 模板引擎\n- CSS预处理器\n- Hexo 文档\n\n本文使用的模板引擎为 [ejs](http://www.embeddedjs.com/)，使用的 CSS 预处理器为 [stylus](http://stylus-lang.com/)。这也是 hexo 项目预装了的 render 插件，如果想使用其他模板引擎或者其他 CSS 预处理器，可以安装相对应的 render 插件。例如我的 [Even](https://github.com/ahonn/hexo-theme-even) 主题使用的是 Swig 与 SCSS。\n\n本文的代码： [theme-example](https://github.com/ahonn/theme-example) 。\n\n<!--more-->\n\n## 目录结构\n主题目录结构以自带的 [landscape](https://github.com/hexojs/hexo-theme-landscape) 主题为例：\n\n```\n.\n├── languages  语言文件，用于国际化\n├── layout     页面模板文件\n├── scripts    Hexo 脚本\n└── source     主题资源文件，包括页面样式，脚本，字体等\n```\n\n我们在 `themes` 中新建 `theme-example` 文件夹，然后在 `theme-example` 中按照 landscape 主题的目录结构新建 `languages`，`layout`，`scripts` 与 `source` 文件夹。\n\n## 创建布局模板\n在 `layout` 中创建 `index.ejs` 文件，首页将会使用该布局模板生成 HTML 文件。\n\n`layout/index.ejs`:\n\n``` html\n<html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n    <meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\">\n    <title>Home</title>\n  </head>\n  <body>\n    <h1>Hello Word</h1>\n  </body>\n</html>\n```\n\n修改站点配置文件中的主题配置，使用我们刚刚创建的 `theme-example` 主题：\n\n``` yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: theme-example\n```\n\n运行 `hexo server --debug` 以 debug 模式开启 Hexo 本地服务器预览，访问 [http://localhost:4000/](http://localhost:4000/)。\n\n![Hello World](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6up8p.jpg)\n\n## 添加页面导航\n\n现在我们需要在页面中添加导航，由于导航不单单会在首页出现，所以我们在 `layout` 中创建共用的布局文件 `layout.ejs`， 同时创建 `_partial/head.ejs` 保存 HTML 的 head 以及创建 `_partial/header.ejs` 文件，编写页面导航部分。\n\n`layout/layout.ejs`:\n``` html\n<!DOCTYPE html>\n<html>\n  <%- partial('_partial/head') %>\n  <body>\n    <%- partial('_partial/header') %>\n    <main class=\"main\">\n      <%- body %>\n    </main>\n  </body>\n</html>\n```\n\n`layout.ejs` 文件通过 `partial()` 函数来包含其他文件，使得我们能够更好的组织代码。详见 [Templates | Hexo](https://hexo.io/docs/templates.html#Partials)。\n\n`layout/_partial/head.ejs`:\n``` html\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\">\n  <title><%= config.title %></title>\n</head>\n```\n\n这里使用了 `config` 变量，该变量包含的是站点配置（即站点根目录下 `_config.yml` 中的配置）。除此之外，Hexo 还提供了许多变量可在模板中使用，详见 [Variables | Hexo](https://hexo.io/docs/variables.html)。\n\n`layout/_partial/header.ejs`:\n``` html\n<header class=\"header\">\n  <div class=\"blog-title\">\n    <a href=\"<%- url_for() %>\" class=\"logo\"><%= config.title %></a>\n  </div>\n  <nav class=\"navbar\">\n    <ul class=\"menu\">\n      <li class=\"menu-item\">\n        <a href=\"/\" class=\"menu-item-link\">Home</a>\n      </li>\n      <li class=\"menu-item\">\n        <a href=\"/archives\" class=\"menu-item-link\">Archive</a>\n      </li>\n    </ul>\n  </nav>\n</header>\n```\n\n接着我们清空 `index.ejs` 中的内容，并添加 `<h2>Hello World</h2>`。在 `layout` 目录下的 `index.ejs` 会自动继承 `layout.ejs`，并将其中的内容填入 `<%- body %>` 的位置。我们将得到一个有导航菜单的 Hello World 页面。\n\n![Index](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/v7x9h.jpg)\n\n## 添加主题配置文件\n\n实际上我们需要让导航菜单根据我们的需要显示不同的项，上面这种写法不方便修改。所以我们会在主题的配置文件中添加导航菜单的配置。在 `thmem-demo` 下新建主题的配置文件 `_config.yml`，在其中添加需要配置的字段。然后可以通过 `theme` 这个变量来拿到该配置文件中的配置。\n\n`theme-example/_config.yml`:\n\n``` yml\nmenu:\n  Home: /\n  Archives: /archives\n```\n\n这样我们就可以在 `header.ejs` 中使用 `theme.menu` 获取到导航菜单的设置。将 `header.ejs` 修改为：\n\n``` html\n<header class=\"header\">\n  <div class=\"blog-title\">\n    <a href=\"<%- url_for() %>\" class=\"logo\"><%= config.title %></a>\n  </div>\n  <nav class=\"navbar\">\n    <ul class=\"menu\">\n      <% for (name in theme.menu) { %>\n        <li class=\"menu-item\">\n          <a href=\"<%- url_for(theme.menu[name]) %>\" class=\"menu-item-link\"><%= name %></a>\n        </li>\n      <% } %>\n    </ul>\n  </nav>\n</header>\n```\n\n当需要在导航中添加链接的时候就可以在配置文件中直接添加，例如添加 Github 的链接：\n\n``` yml\nmenu:\n  Home: /\n  Archives: /archives\n  Github: https://github.com/ahonn\n```\n\n除此之外还可以添加其他需要的配置，例如 RSS，评论等等。\n\n## 添加首页文章列表\n接着我们完善首页的模板，使其能够显示文章列表。前面已经说过 Hexo 提供了各种有用的变量，在这里将会使用到 `page` 这个变量。`page` 会根据不同的页面拥有不同的属性。具体有什么属性，可以获取到哪些数据可以查看[这里](https://hexo.io/docs/variables.html#Page-Variables)。\n\n那么这里我们会使用 `page` 变量的 `posts` 属性拿到文章数据的集合。编辑 `index.ejs` 文件：\n\n``` html\n<section class=\"posts\">\n  <% page.posts.each(function (post) { %>\n    <article class=\"post\">\n      <div class=\"post-title\">\n        <a class=\"post-title-link\" href=\"<%- url_for(post.path) %>\"><%= post.title %></a>\n      </div>\n      <div class=\"post-content\">\n        <%- post.content %>\n      </div>\n      <div class=\"post-meta\">\n        <span class=\"post-time\"><%- date(post.date, \"YYYY-MM-DD\") %></span>\n      </div>\n    </article>\n  <% }) %>\n</section>\n```\n\n从 `page.posts` 中获取单篇文章的数据，并获取文章的标题，内容等数据填充到模板中。处理文章创建时间的时候使用了 `date()` 函数，这是 Hexo 提供的时间处理的[辅助函数](https://hexo.io/docs/helpers.html#date)。本文中使用到的函数如无特别说明，即为 Hexo 的辅助函数。\n\n### 文章摘录\n\n由于首页显示文章内容时使用的是 `post.content`，即文章的全部内容。所以首页会显示每一篇文章的内容，实际上我们并不想在首页显示那么多内容，只想显示文章的摘录。\n\nHexo 提供了 `excerpt` 属性来获取文章的摘录部分，不过这里需要在文章中添加一个 `<!--more-->` 标记。添加了这个标记之后，`post.excerpt` 将会获取到标记之前的内容。如果没有这个标记，那么 `post.excerpt` 会是空的。所以我们可以把首页文章内容部分的 `post.content` 替换成 `post.excerpt`。\n\n``` html\n<div class=\"post-content\">\n  <%- post.excerpt %>\n</div>\n```\n\n## 添加页面样式\n到目前为止，我们完成了首页的页面结构，但是并没有添加样式，所以看起来很丑。我们在 `source` 文件中创建一个 `css` 文件夹来存放样式文件。\n\n由于 Hexo 在新建项目的时候会安装 `hexo-renderer-stylus` 这个插件，所以我们无需其他步骤，只需要将样式文件放到 `css` 文件夹中。Hexo 在生成页面的时候会将 `source` 中的所有文件复制到生成的 `public` 文件中，并且在此之前会编译 styl 为 css 文件。\n\n在 `css` 文件夹中创建 `style.styl`，编写一些基础的样式，并把所有样式 `import` 到这个文件。所以最终编译之后只会有 `style.css` 一个文件。创建 `_partial/header.styl` 与 `_partial/post.styl` 存放页面导航以及文章的样式，并且在 `style.styl` 中 `import` 这两个文件。\n\n`_partial/header.styl`:\n\n``` stylus\n.header {\n  margin-top: 2em\n  display: flex\n  align-items: baseline\n  justify-content: space-between\n\n  .blog-title .logo {\n    color: #AAA;\n    font-size: 2em;\n    font-family: \"Comic Sans MS\",cursive,LiSu,sans-serif;\n    text-decoration: none;\n  }\n\n  .menu {\n    margin: 0;\n    padding: 0;\n\n    .menu-item {\n      display: inline-block;\n      margin-right: 10px;\n    }\n\n    .menu-item-link {\n      color: #AAA;\n      text-decoration: none;\n\n      &:hover {\n        color: #368CCB;\n      }\n    }\n  }\n}\n```\n\n`_partial/post.style`:\n\n``` stylus\n.post {\n  margin: 1em auto;\n  padding: 30px 50px;\n  background-color: #fff;\n  border: 1px solid #ddd;\n  box-shadow: 0 0 2px #ddd;\n}\n\n.posts  {\n  .post:first-child {\n    margin-top: 0;\n  }\n\n  .post-title {\n    font-size: 1.5em;\n\n    .post-title-link {\n      color: #368CCB;\n      text-decoration: none;\n    }\n  }\n\n  .post-content {\n    a {\n      color: #368CCB;\n      text-decoration: none;\n    }\n  }\n\n  .post-meta {\n    color: #BABABA;\n  }\n}\n```\n\n`style.styl`:\n\n``` stylus\nbody {\n  background-color: #F2F2F2;\n  font-size: 1.25rem;\n  line-height: 1.5;\n}\n\n.container {\n  max-width: 960px;\n  margin: 0 auto;\n}\n\n@import \"_partial/header\";\n@import \"_partial/post\";\n```\n\n最后，我们需要把样式添加到页面中，这里使用了另外一个辅助函数 [`css()`](https://hexo.io/docs/helpers.html#css):\n\n`layout/_partial/head.ejs`\n``` html\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\">\n  <title><%= config.title %></title>\n  <%- css('css/style.css') %>\n</head>\n```\n\n至此，我们会看到站点的首页是这个样子的：\n\n![Home Page](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/z38nr.jpg)\n\n**注意，这里会报错。原因是生成文章页时没有找到对应的模版，所以使用了首页的模版，但文章页并没有 `page.posts` 这个属性（undefined 没有 each 方法）。新建 post.ejs 即可解决，或直接跳过直到完成文章页模版。**\n\n## 添加分页\n在站点的 `source/_post/` 目录下存放的是我们的文章，现在我们把原本的 `hello-world.md` 复制黏贴 10+ 次，再查看站点首页。会发现，首页只显示了 10 篇文章。\n\n首页显示的文章数量我们可以通过站点配置文件中的 `per_page` 字段来修改，但是我们不可能把所有文章都放在一页，所以我们现在来添加文章列表的分页。\n\n新建 `_partial/paginator.ejs`:\n\n``` html\n<% if (page.total > 1){ %>\n  <nav class=\"page-nav\">\n    <%- paginator({\n      prev_text: \"&laquo; Prev\",\n      next_text: \"Next &raquo;\"\n    }) %>\n  </nav>\n<% } %>\n```\n\n在 `index.ejs` 中添加这个文件的内容：\n\n``` html\n...\n</section>\n<%- partial('_partial/paginator') %>\n```\n\n这里我们使用到了另外的一个辅助函数 [`paginator`](https://hexo.io/docs/helpers.html#paginator)，它能够帮助我们插入分页链接。\n\n## 添加文章详情页\n文章详情页对应的布局文件是 `post.ejs`，新建 `post.ejs`:\n\n``` html\n<article class=\"post\">\n  <div class=\"post-title\">\n    <h2 class=\"title\"><%= page.title %></h2>\n  </div>\n   <div class=\"post-meta\">\n    <span class=\"post-time\"><%- date(page.date, \"YYYY-MM-DD\") %></span>\n  </div>\n  <div class=\"post-content\">\n    <%- page.content %>\n  </div>\n</article>\n```\n\n由于这里是文章的模板，所以变量 `page` 表示的是文章的数据，而不是首页的文章数据集合。\n\n## 添加归档页\n创建归档页使用的模板文件 `archive.ejs`:\n\n``` html\n<section class=\"archive\">\n  <ul class=\"post-archive\">\n    <% page.posts.each(function (post) { %>\n      <li class=\"post-item\">\n        <span class=\"post-date\"><%= date(post.date, \"YYYY-MM-DD\") %></span>\n        <a class=\"post-title\" href=\"<%- url_for(post.path) %>\"><%= post.title %></a>\n      </li>\n    <% }) %>\n  </ul>\n</section>\n<%- partial('_partial/paginator') %>\n```\n\n其实结构跟首页差不多，只是不显示文章内容而已。添加归档页的样式：\n\n`css/_partial/archive.styl`:\n\n``` stylus\n.archive {\n  margin: 1em auto;\n  padding: 30px 50px;\n  background-color: #fff;\n  border: 1px solid #ddd;\n  box-shadow: 0 0 2px #ddd;\n\n  .post-archive {\n    list-style: none;\n    padding: 0;\n\n    .post-item {\n      margin: 5px 0;\n\n      .post-date {\n        display: inline-block;\n        margin-right: 10px;\n        color: #BABABA;\n      }\n\n      .post-title {\n        color: #368CCB;\n        text-decoration: none;\n      }\n    }\n  }\n}\n```\n\n## 国际化\n还记得我们一开始创建的 `languages` 文件夹吗？没错，它是用来添加多种语言，用于 i18n 的。站点的语言设置为站点配置文件中的 `language`。\n\n当该字段为空时，默认使用的是 `languages/default.yml` 这个文件。那么现在我们来添加这个文件，我们决定主题的默认语言是英文：\n\n``` yml\nMenu:\n  Home: Home\n  Archives: Archives\n  Github: Github\n\nPaginator:\n  Prev: Prev\n  Next: Next\n```\n\n目前我们需要主题根据选择的语言自动修改的有上面这些，接着我们需要修改 `header.ejs` 与 `paginator.ejs` 这两个文件：\n\n`_partial/header.ejs`\n``` html\n<header class=\"header\">\n  <div class=\"blog-title\">\n    <a href=\"<%- url_for() %>\" class=\"logo\"><%= config.title %></a>\n  </div>\n  <nav class=\"navbar\">\n    <ul class=\"menu\">\n      <% for (name in theme.menu) { %>\n        <li class=\"menu-item\">\n          <a href=\"<%- url_for(theme.menu[name]) %>\" class=\"menu-item-link\"><%- __('Menu.' + name) %></a>\n        </li>\n      <% } %>\n    </ul>\n  </nav>\n</header>\n```\n\n`_partial/paginator.ejs`:\n``` html\n<% if (page.total > 1){ %>\n  <nav class=\"page-nav\">\n    <%- paginator({\n      prev_text: \"&laquo;\" + __('Paginator.Prev'),\n      next_text: __('Paginator.Next') + \"&raquo;\"\n    }) %>\n  </nav>\n<% } %>\n```\n\n修改之后其实与之前相比没有什么变化，起码看起来是。现在我们添加一个中文的文件：\n\n`languages/zh-CN.yml`\n``` yml\nMenu:\n  Home: 首页\n  Archives: 归档\n  Github: 交友\n\nPaginator:\n  Prev: 上一页\n  Next: 下一页\n```\n\n然后我们将站点配置文件中的 `language` 字段修改为 `zh-CN`（与 `zh-CN.yml` 文件名相同）。再次访问站点之后就会发现导航与分页部分的文字变成了中文。\n\n## 最后总结\n\n如果你有耐心看我废话了这么多的话，恭喜你，你应该对怎么去写一个 Hexo 主题有了一定的了解。其实说白了，Hexo 就是把那些 Markdown 文件按照不同的布局模板，填上对应的数据生成 HTML 页面，复制 `source` 中的到生成的 `public` 文件夹中，中间过程会把需要编译的 stylus/less/sass 等文件编译。\n\n本文并没有提及有关页面 JavaScript 的部分，实际上与写 CSS 样式相同。在 `source/js` 中写 JavaScript 脚本，然后在模板中引入即可。\n\n感谢阅读，希望对你有所帮助。\n","timeToRead":10}},{"node":{"id":"d428a7f7-648f-53d1-9cea-14c7d94de544","frontmatter":{"title":"2016 年终总结","date":"2016/12/13","tags":["年终总结"]},"fields":{"slug":"/posts/2016121332"},"excerpt":"一转眼 2016 年就快要结束了，这一年对自己来说收获了很多。 去年的总结，给自己定下了个 2016 年的计划。现在 2016 也差不多快结束了，我对自己执行的情况还是比较满意的。 关于 Github 去年年底参加了 Github 上的一个编程马拉松，一开始 commit 都是…","rawMarkdownBody":"\n一转眼 2016 年就快要结束了，这一年对自己来说收获了很多。\n\n去年的总结，给自己定下了个 2016 年的计划。现在 2016 也差不多快结束了，我对自己执行的情况还是比较满意的。\n\n## 关于 Github\n去年年底参加了 Github 上的一个编程马拉松，一开始 commit 都是没有断过的，但是之后慢慢的总会有抓脑袋想 commit 的状况出现。不能说这样不好，只不过会让自己为了 commit 而 commit，本末倒置了。所以后面就不再管是否连续 commit 了，也把之前几个自己觉得不行的项目给删除了。贴一张今年 Github 上的 commit 图，虽然还是有很多质量不高的提交，但也算是今年对自己的付出的一点交代了。\n\n![Github Commit](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/m37e8.jpg)\n\n<!--more-->\n\n大多数的提交都贡献自 [hexo-theme-even](https://github.com/ahonn/hexo-theme-even) 这个项目。放假在家的时候突然想自己写个博客的主题，结果说干就干，就写起来了。到目前为止已经重构了两遍了，每一次都能够发现之前写的不好的地方。不过在这个过程中明白了一点，不能为了写代码而写代码，应该更加关注用户体验。之前写的时候完全是自己能用就好的，后来使用的人越来越多了，就需要关注一些之前自己不会关注到的点。\n\n更深刻的体会到，设计与规划应该占到的比重应该远远大于编码的比重。这就好比盖房子，一股脑的搬砖盖最后可能盖出来的是歪楼。\n\n## 关于实习\n\n暑假的时候没有回家，找了一个技术相关的暑假实习。当然，所谓暑假实习就是打打下手咯。不过期间也参与了个很有意思的项目，不过因为是比较偏重后端的公司（使用的大多是 Ruby），所以前端部分都是自己折腾，没有学到什么东西。\n\n在实习期间也学到了非常多的东西，比如说怎么使用 git 进行团队协作，写页面的时候要注重用户体验，一个按钮或者一个文本的位置都需要慎重思考。由于公司比较小，感受不到比较浓厚的技术气氛。所以希望大三结束的这份实习能够找到自己所期望的那样技术气氛浓厚的公司来实习。\n\n## 关于读书\n\n暑假实习的时候由于是一个人住，每天上下班都要在地铁上花费一个多钟的时间。所以在一开始的时候就用了京东白条预先买了个 Kindle，然后在实习的这段时间里看完了《乔布斯传》，《解忧杂货店》，《人性的弱点》以及《安静》。关于读书，想起了一个知乎上的一个回答：[读了很多书，但是都忘掉了，读书的意义在哪里？ - 尧大力的回答 - 知乎](https://www.zhihu.com/question/22456239/answer/45671305)，深以为然。读书对我的影响还是很大的，会改变对事物的看法。不是有句话说，读万卷书，行万里路。所以要多读书，以后有机会的话也要多出去走走。\n\n除了看这些书之外，也看了一些技术性的书籍。实习之前看了本《深入理解 bootstrap》，这个在我实习的时候用 bootstrap 的时候有很大帮助。还有一些 JavaScript 相关的书，高程三打算在大三实习之前再刷多一次。\n\n有点小遗憾的是，我依旧没有看完 SICP（Structure and Interpretation of Computer Programs\n），看了前两章就没有看了。所以明年的计划里面会加上看完这本书。此外，双十一的时候也买了好几本技术类书籍，其实都是为了到时候面试而准备的，正好也是需要补补基础。其实更关键的一点是太穷只能买书了...\n\n## 关于生活\n\n今年回家的时间比较少，前半年在学校，后半年在学校，中间实习在广州一个人住。第一次离家还是一个人生活，让我这样一个不会照顾自己的人也慢慢的学会了照顾自己。同时也明白了很多事情，一个人的时候要好好的，不能让父母担心。\n\n## 关于来年\n\n2018 年就正式毕业了，也就是说在学校的时间不多了，希望自己能好好过完这最后的学生时光。\n\n无例外，今年的总结也要对新的一年列个计划。\n\n- 继续好好维护博客主题\n- 完成 leetcode 上的前 150 道题目\n- 读完买的那些书，包括不限于高程三，SICP\n- 写自己的简历网站\n- 多运动，久坐对身体不好\n- 有机会多出去走走\n","timeToRead":1}},{"node":{"id":"2729652a-ca30-5fe3-9457-29a18fc49f4b","frontmatter":{"title":"JavaScript 创建对象的一些姿势","date":"2016/11/30","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016113031"},"excerpt":"工厂模式 在函数中创建 Object 对象，并为对象添加属性。函数返回添加属性之后的对象。 但工厂模式产生的对象依旧为 Object 类型，只是在对象上添加了一些属性。 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型） 构造函数模…","rawMarkdownBody":"\n## 工厂模式\n在函数中创建 Object 对象，并为对象添加属性。函数返回添加属性之后的对象。\n\n``` js\nfunction createPerson(name, age) {\n  var o = new Object()\n  o.name = name\n  o.age = age\n  o.sayName = function () {\n    console.log(this.name)\n  }\n  return o\n}\n\nvar p = createPerson(\"ahonn\", 21)\n```\n\n<!--more-->\n\n但工厂模式产生的对象依旧为 Object 类型，只是在对象上添加了一些属性。\n\n> 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）\n\n## 构造函数模式\n由于工厂模式创建的对象没有解决对象识别的问题，出现了另外一种新模式：构造函数模式。\n\n``` js\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  this.sayName = function () {\n    console.log(this.name)\n  }\n}\n\nvar p = new Person(\"ahonn\", 21)\n```\n\n这里使用了 `new` 操作符，即是将 Person 函数通过构造函数的方式去调用来创建对象。\n\n构造函数会进行下面几个步骤：\n- 创建一个新对象\n- 将构造函数的 this 指向新对象\n- 通过 this 给对象添加属性\n- 返回新对象\n\n使用构造函数模式创建的对象可以通过 `constructor` 属性查看对象的类型。\n\n``` js\nconsole.log(p.constructor) // Person\n```\n\n### 构造函数也是普通函数\n构造函数与普通的函数无异，也可以直接调用构造函数。但此时就不会创建新对象，函数中的 this 指向的是函数当前所在的作用域。\n\n``` js\nPerson(\"ahonn\", 21)\nthis.sayName() // ahonn\n```\n\n## 原型模式\n通过构造函数模式创建的对象有一个问题，就是创建的对象各自拥有自己的方法，而实际上这些方法都是相同的。通过原型模式即可以将共同的属性方法放在 prototype 上。\n\n``` js\nfunction Person() {}\n\nPerson.prototype.name = \"ahonn\"\nPerson.prototype.age = 21\nPerson.prototype.sayName = function () {\n  console.log(this.name)\n}\n\nvar p1 = new Person()\np1.sayName() // \"ahonn\"\n\nvar p2 = new Person()\np2.sayName() // \"ahonn\"\n```\n\n对象在 prototype 上的属性是共享的，即修改一个对象的某个属性，另一个对象对于的属性值也会改变。\n\n``` js\np1.name = \"test\"\np1.sayName() // test\n\np2.sayName() // test\n```\n\n## 构造函数与原型模式\n使用原型模式创建的对象共享 prototype 上的属性，那么当有些属性不想要对象之间共享的时候，就可以结合构造函数模式与原型模式来使用。这也是最常用的创建对象的方式。\n\n``` js\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n}\n\nPerson.prototype.sayName = function () {\n  console.log(this.name)\n}\n\nvar  p1 = new Person(\"ahonn\", 21)\np1.sayName() // \"ahonn\"\n\nvar p2 = new Person(\"test\", 12)\np2.sayName() // \"test\"\n```\n\n## ES6 类\n在 ES6 中有类似于 Java 创建对象的方式，即通过类来创建对象。ES6 中提供了 `class` 关键字，来声明一个类型，并如上面构造函数模式的方式一样使用 `new` 来声明对象。虽然可以使用类似 Java 中的 `class` 来声明，但实际上只是给构造函数与原型模式加上了语法糖，使得代码看起来更加易读。\n\n还是 Person 类的例子\n``` js\nclass Person {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n\n  sayName() {\n    console.log(this.name)\n  }\n}\n\nvar p = new Person(\"ahonn\", 21)\np.sayName() // \"ahonn\"\n```\n\n通过 `class` 关键字声明 Person 类，`constructor` 函数即为 Person 类的构造函数，类属性的初始化也在其中。需要在各个对象中共享的方法也写在 `class` 中，避免了原来定义在 `prototype` 上时的撕裂感。\n","timeToRead":2}},{"node":{"id":"1bc794fe-5970-5992-af6b-8827594a9e41","frontmatter":{"title":"JavaScript 数据类型判断","date":"2016/11/21","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016112130"},"excerpt":"最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。 Object.prototype.toString() 在进行类型判断时，使用到最多的当属  。  方法返回一个代表该对象的字符串。每个对象都…","rawMarkdownBody":"\n最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。\n\n## Object.prototype.toString()\n在进行类型判断时，使用到最多的当属 `Object.prototype.toString()`。\n\n`toString()` 方法返回一个代表该对象的字符串。每个对象都会继承 Object 上的 `toString` 方法，如果该方法没有被同名方法覆盖的话。使用 `toString()` 方法将会返回字符串 `\"[object type]\"`。其中 type 根据对象的类型的不同而不同。\n\n关于 `Object.prototype.toString()` 的详细描述可以查看：[Object.prototype.toString() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString)\n\n<!--more-->\n\n## 使用 toString() 判断类型\n由于 `toString()` 会返回带有类型信息的字符串，所以通常可以使用它来进行数据类型的判断。\n\nunderscore 中对一些数据类型的判断实现：\n\n```js\n_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n  _['is' + name] = function(obj) {\n    return toString.call(obj) === '[object ' + name + ']';\n  };\n});\n```\n\n通过 `toString()` 函数的返回值判断类型，这里不使用 `typeof` 判断的原因是字面量与对象的返回值不同。\n\n例如字符串字面量 `\"1\"` 通过 `typeof` 操作符返回的是 `\"string\"`，而字符串对象 `new String('1')` 通过 `typeof` 操作符返回的却是 `\"object\"`。所以通过 `Object.prototype.toString()` 来进行判断最为妥当。\n\n## 判断 NaN，null，undefined\n\n### NaN\n在 JavaScript 的 Number 类型中有这样一个特殊的存在，那就是 `NaN`。`NaN` 的意思是 Not-A-Number，即不是一个数字。当对无法转换为数字的变量进行数字转换时就会得到 `NaN`。`Nan` 还有一个特殊的性质，就是 `NaN === NaN` 返回的是 false。\n\n所以对 NaN 的判断的实现如下：\n\n``` js\n_.isNaN = function(obj) {\n  return _.isNumber(obj) && isNaN(obj);\n};\n```\n\n先判断是否为 Number 类型，排除隐式类型转换造成的误判。再使用 isNaN 函数判断是否为 NaN。\n\n### null\n在 JavaScript 中有 `==` 与 `===` 两个相等操作符，后者为严格比较。`null == undefined` 的返回值是 true，所以不能使用这个来判断是否为 null。而 `null === undefined` 返回的是 false，因此使用严格相等哎判断是否为 null。而\n\n``` js\n_.isNull = function(obj) {\n  return obj === null;\n};\n```\n\n### undefined\n判断变量是否为 `undefined`，很自然会想到使用 `foo === undefined` 的方式来判断。但是这样做是不安全的，在旧的浏览器版本上 `undefined` 是可以被重写的。这时使用上面那样判断会出现这种状况：\n\n``` js\nundefined = 'foo';\nvar foo = 'foo';\n\nconsole.log(foo === undefined); // true\n```\n\n所以这种判断方式不被推荐，即使新版本的浏览器上无法重写 undefined。更推荐的方式是使用 `void 0` 来判断。\n关于 `void 0` 与 `undefined` 可以参考我在知乎上的回答：[（void 0）在javascript中表示什么，和undefined有什么区别？](https://www.zhihu.com/question/52645620/answer/131470539)\n\n推荐的 undefined 判断实现：\n\n``` js\n_.isUndefined = function(obj) {\n  return obj === void 0;\n};\n```\n\n## 判断 Object\n在 underscore 中对对象类型的判断是通过 `typeof` 来实现的：\n\n``` js\n_.isObject = function(obj) {\n  var type = typeof obj;\n  return type === 'function' || type === 'object' && !!obj;\n};\n```\n\n`typeof` 操作符在变量为 `null` 或者是对象时返回 `\"object\"`，在变量为函数对象时返回 `function`。\n\n我们需要的是判断变量是否为对象，那么就需要排除 `null` 的情况，即将变量进行两次取反操作，将变量转换为 `Boolean` 类型。由于 `null` 会转换为 `false`，那么这样就可以排除 `null` 的干扰。\n","timeToRead":2}},{"node":{"id":"7552bc95-08d4-5972-8900-3019c891b147","frontmatter":{"title":"「微信小程序」入坑总结","date":"2016/11/14","tags":["JavaScript","Wechat"]},"fields":{"slug":"/posts/2016111429"},"excerpt":"前段时间去了广州参加了关于「微信小程序」的技术沙龙，整场下来收获颇多。实际上微信小程序刚刚发布出来的时候就关注，弄了破解了的开发工具，跑了个官方的 Demo。 听完回来之后就想着挖个相关的坑，正好看到手机上的 「ONE · 一个」。上网找到了 ONE 的接口，打算搞一个仿照 O…","rawMarkdownBody":"\n前段时间去了广州参加了关于「微信小程序」的技术沙龙，整场下来收获颇多。实际上微信小程序刚刚发布出来的时候就关注，弄了破解了的开发工具，跑了个官方的 Demo。\n\n听完回来之后就想着挖个相关的坑，正好看到手机上的 「ONE · 一个」。上网找到了 ONE 的接口，打算搞一个仿照 ONE 官方 APP 的小程序，最后就有了 [weapp-one](https://github.com/ahonn/weapp-one) 这个项目。\n\n## 关于小程序\n\n微信小程序不是 Web 也不是 Native，尝试之后给我的感觉有点像是 weex。因为之前尝试 weex 的时候是下载一个 APP，然后通过应用内扫码来运行对应的应用。这一点上小程序类似。\n\n在沙龙上有位分享嘉宾有提到，小程序实际上是在 Webview 之上再加上一层原生的组件。例如底部的 tabbar 以及顶部的 navbar 就是原生的。还有小程序的 map 组件，是调用原生的 map 组件。\n\n<!--more-->\n\n## 请求限制\n\n一开始就遇到了问题，ONE 官方的接口是 http 的，而且是 8000 这个端口。微信小程序对发送的请求有限制，必须是 https（在本地开发可以用 http），而且不能带端口号。\n\n所以我就使用了比较暴力的方法，把开发工具中对应用来限制的代码给注释掉了，反正只是用来体验一下小程序开发，所以就无所谓了。\n\n## 添加页面\n\n在小程序中添加页面都需要将路径添加到 `app.json` 中的 `page` 项中，否则会找不到页面。与 Vue 类似，每个小程序页面包含 `page.js`，`page.wxml`，`page.wxss`，分别对应脚本，模板以及样式。\n\n还可以添加一个 `page.json` 对页面进行单独配置，比如配置 `navigationBarTitleText` 来改变导航上的文字显示，诸如此类的对页面的窗口表现配置。\n\n## 奇怪的组件\n\n**view、text**\n在 wxml 里面写的是类似 HTML 的标签，标准的 HTML 标签是无法使用的。只能使用微信小程序官方的组件，组件对应有一些属性或事件可以调用。有类似于 `<div>` 的 `<view>` 组件，基本上页面上的组件都会被 `<view>` 包裹住。\n然后文字方面是使用 `<text>`，虽然直接显示文字也没什么问题。不过我还是把所有的文字都加上了 `<text>` 标签。\n\n**image**\n说起组件，微信小程序里最让我不爽的就是 `<image>` 这个组件了。给这个组件一个图片地址之后，默认的样式不是图片的大小，而是固定的 300px * 225px。与 HTML 中的 `<img>` 完全不同，用起来有点不舒服。\n`<image>` 组件还提供了不同显示方式的 mode，不过用起来还是觉得怪怪的。\n\n**audio**\n音频播放的话有 `<audio>` 这个组件，但是这个组件的样式好像是固定的，类似于在网页也加上网易云音乐的外链那样。不过幸好有音频播放相关的 api 可以用，这样就可以当用户触发某些操作的时候播放音频，即可实现播放按钮点击后播放音频。\n\n微信小程序在播放音频的时候，开发工具上会出现对应的音乐栏，可以对播放的音频进行播放/暂停。猜猜在真机上使用时，会在通知栏出现音频控制。上面会显示音频的作者以及歌曲名称。但是在实际使用中有一点比较尴尬，使用调用 api 的方式播放音频没有设置音频作者的选项。详情可以见 [音乐播放控制 · 小程序](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-background-audio.html?t=20161107#wxplaybackgroundaudioobject)\n\n**video**\n相较与 HTML5 中的 `<video>` 标签，微信小程序中的 `<video>` 组件缺失了很多东西，例如 `loop` 与 `poster`。也就是说无法在用户点击播放按钮前显示特定的图像，只能是显示视频最开头。\n`<video>` 组件同样有默认的尺寸 300px * 225px，但没有 `<image>` 组件中的显示模式的设置。未全屏状态下，在不同的分辨率上，上下或者左右可能会存在黑边。\n\n## 特殊的 rpx\n微信小程序中有特有的一个尺寸单位 —— rpx，1rpx 表示屏幕宽度的 1/750 大小，也就是说，100% 宽度就是 750rpx。还有一个会被忽略的尺寸单位 —— rem，与 Web 中的 rem 不同，1rem 表示屏幕宽度的 1/20 大小。\n\n在高度上使用 rpx 的话，也会根据屏幕的宽度的大小而改变。我更倾向与宽度使用 rpx 而高度使用 rem，不过其实比较喜欢用 px 来写样式，这可能算是一个不好的习惯。\n\n## 实现滑至最右切换页面\n\n在仿照 ONE 写微信小程序的时候遇到了一个问题，使用滑块视图组件 `<swiper>` 去显示每日图文，一共10个图文，当滑动至最右时切换到选择往期列表的页面。如下图所示：\n\n![One](//ouv0frko5.bkt.clouddn.com/3qpaf.jpg)\n\n但是 `<swiper>` 组件并没有提供对应的事件，使用就自己实现了一个。主要是使用滑块视图每一次切换视图时都会触发一个 `bindchange` 事件，还有设置滑块视图显示位置的 `current` 属性。\n\n在 `<swiper>` 组件中添加一个空的 `<swiper-item>` 子组件，当滑动到这个空的子组件的时候使用 `wx.navigateTo` 这个 api 去切换到往期列表这个页面。同时将滑块视图的显示位置设置到倒数第二个，即最后一个非空的子组件。\n\n这样就实现了滑动至最右切换页面的功能，同时在点击返回的时候显示的也是滑块视图中的最后一个有内容的子组件。具体实现代码如下：\n\n``` js\nPage({\n  data: {\n    current: 0\n  },\n  // ......\n  // more code\n  handleChange: function (e) {\n    let current = e.detail.current\n    let length = this.data.vols.length\n\n    if (current === length) {\n      this.setData({\n        current: length\n      })\n      wx.navigateTo({\n        url: '../history/history?page=index',\n        success: () => {\n          this.setData({\n            current: length - 1\n          })\n        }\n      })\n    }\n  }\n})\n```\n\n这里使用了两次 `this.setData` 是因为在第二次执行上面的滑动切换页面再返回的时候，显示的子组件并不是最后一个非空的子组件，而是最后的那个空子组件。大概原因是因为第二次执行这个操作的时候，`current` 并没有更新。\n所以解决的方案是在每次修改 `current` 之前修改一次它的值，使得后面修改 `current` 值时会触发视图的更新。\n","timeToRead":2}},{"node":{"id":"24f7cd11-351e-5389-9dd0-c0eea328e5ef","frontmatter":{"title":"React 路由跳转后回到页面顶部","date":"2016/10/11","tags":["React","前端","JavaScript"]},"fields":{"slug":"/posts/2016101128"},"excerpt":"在 React 组件间进行页面跳转后，发现页面的位置并不在页面顶部，而是在页面跳转前的位置。就是说浏览器的滚动条并没有回到顶部的位置。 经过搜索之后找到了解决方案： Scroll to the top of the page after render in react.js 可…","rawMarkdownBody":"\n在 React 组件间进行页面跳转后，发现页面的位置并不在页面顶部，而是在页面跳转前的位置。就是说浏览器的滚动条并没有回到顶部的位置。\n\n经过搜索之后找到了解决方案：[Scroll to the top of the page after render in react.js](http://stackoverflow.com/questions/33188994/scroll-to-the-top-of-the-page-after-render-in-react-js)\n\n可以使用下面这种解决，但是这种方式不是一种很好的解决方法。而且 `scrollIntoView()` 方法并不回到页面的顶部，应该使用 `scrollTop = 0` 的方式。\n\n``` js\ncomponentDidUpdate = () => { ReactDom.findDOMNode(this).scrollIntoView(); }\n```\n\n所以得到的解决方案是：\n\n``` js\ncomponentDidUpdate() {\n  ReactDOM.findDOMNode(this).scrollTop = 0\n}\n```\n\n<!--more-->\n\n但是我使用这个之后，ESlint 报了个错：`no-find-dom-node`。\n查看 `eslint-plugin-react` 的[文档](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-find-dom-node.md)可以看到 Facebook 不推荐使用 `findDOMNode`，推荐使用 `refs` 获取 DOM 节点。\n\n所以推荐的使用方法是：\n\n``` js\nclass MyComponent extends Component {\n  componentDidMount() {\n    this.node.scrollIntoView();\n  }\n  render() {\n    return <div ref={node => this.node = node} />\n  }\n}\n```\n","timeToRead":1}},{"node":{"id":"3d8cadbf-82ce-5a76-9df6-dc747386835f","frontmatter":{"title":"React 生命周期函数小结","date":"2016/10/02","tags":["JavaScript","前端","React"]},"fields":{"slug":"/posts/2016100227"},"excerpt":"生命周期函数是指，在组件生命周期上的特定点上执行的各个函数。\nReact 的组件声明周期函数分为三种：挂载，更新以及卸载。 挂载 组件挂载的生命周期函数都在初始化渲染前后被调用。 componentWillMount 只调用一次，在客户端与服务端都执行。在初始化渲染之前被调用。…","rawMarkdownBody":"\n生命周期函数是指，在组件生命周期上的特定点上执行的各个函数。\nReact 的组件声明周期函数分为三种：挂载，更新以及卸载。\n\n## 挂载\n组件挂载的生命周期函数都在初始化渲染前后被调用。\n\n### componentWillMount\n只调用一次，在客户端与服务端都执行。在初始化渲染之前被调用。\n\n<!--more-->\n\n### componentDidMount\n只调用一次，在客户端执行，不在服务端执行。在初始化渲染之后被调用。\n使用 `setTimeout` 或 `setInterval`, Ajax 请求等这些操作，均在这个方法内。\n\n## 更新\n所有组件更新的生命周期函数都不会在初始化渲染被调用。\n\n### componentWillReceiveProps\n当组件收到新的 `props` 时被调用。不会在初始化渲染被调用。\n在这个函数里调用 `this.setState() `不会触发任何额外的渲染。（PS: 就是在这里被坑了 T-T）\n\n>  如果需要实现一个对 state 变化相应的操作，使用 [componentWillUpdate](#componentWillUpdate)\n\n### shouldComponentUpdate\n\n当新的 `props` 或者 `state` 被收到，在渲染前被调用。不会在初始化渲染时被调用。\n如果 `shouldComponentUpdate` 返回 `false`，`render()` 会在下次 `state` 变化前被完全跳过。[componentWillUpdate](#componentWillUpdate)  和 [componentDidUpdate](#componentDidUpdate)  将不会被调用。\n\n### componentWillUpdate\n当新的 `props` 或者 `state` 被收到，在渲染前被立即调用。不会在初始化渲染被调用。\n**不能在这个方法里使用 `this.setState() `。**\n\n### componentDidUpdate\n在组件的更新被更新到 DOM 后立即被调用。不会在初始化渲染被调用。\n\n## 卸载\n\n### componentWillUnmount\n在组件卸载前被调用，主要用来执行一些组件的清理工作。\n","timeToRead":1}},{"node":{"id":"804cda2a-573e-5af9-a749-0adfe6ade09a","frontmatter":{"title":"正则表达式备忘录","date":"2016/09/13","tags":["JavaScript","前端","RegExp"]},"fields":{"slug":"/posts/2016091326"},"excerpt":"JavaScript 创建正则表达式有两种方式： 使用正则表达式字面量： 调用 RegExp 对象的构造函数： 什么时候使用构造函数？ 当正则表达式的模式会变发生改变，或者需要从其他地方得到时（例如用户输入），适合使用构造函数的方式。 匹配字符表 ：将其后的特殊字符转义为字面量…","rawMarkdownBody":"\nJavaScript 创建正则表达式有两种方式：\n- 使用正则表达式字面量：`var re = /abc/;`\n- 调用 RegExp 对象的构造函数：`var re = new RegExp(\"abc\");`\n\n## 什么时候使用构造函数？\n当正则表达式的模式会变发生改变，或者需要从其他地方得到时（例如用户输入），适合使用构造函数的方式。\n\n<!--more-->\n\n## 匹配字符表\n- `\\`：将其后的特殊字符转义为字面量\n- `^`：匹配输入的开始\n- `$`：匹配输入的结束\n- `*`：匹配前一个表达式0次或者多次，等价于 {0,}\n- `+`：匹配前一个表达式1次或多次，等价于 {1,}\n- `?`：匹配前一个表达式0次或者1次，等价于 {0,1}\n- `.`：匹配除了换行符（\\n）之外的任何单个字符\n- `(x)`：匹配 ‘x’ 并记住匹配项\n- `(?:x)`：匹配 ‘x’ 但不记住匹配项\n- `x(?=y)`: 匹配 ‘x’ 并且 ‘x’ 后面跟着 ‘y’，也叫作正向肯定查找\n- `x(?!y)`：匹配 ‘x’ 并且 ‘x’ 后面不跟着 ‘y’，也叫作正向否定查找\n- `x | y`：匹配 ‘x’ 或者 'y'\n- `{n}`：匹配前一个字符 n 次\n- `{n, m}`：匹配前一个字符最少 n 次\n- `[xyz]`：匹配括号中的任意一个字符，可以使用 `-` 指定范围\n- `[^xyz]`: 匹配任何不在括号中的字符\n- `\\b`：匹配一个词的边界\n- `\\B`：匹配非单词边界\n- `\\d`：匹配一个数字\n- `\\D`：匹配一个非数字字符，等价于 [^0-9]\n- `\\f`：匹配一个换页符\n- `\\n`：匹配一个换行符\n- `\\r`: 匹配一个回车符\n- `\\s`：匹配一个空白字符\n- `\\S`：匹配一个非空白字符\n- `\\t`：匹配一个水平制表符\n- `\\v`: 匹配一个垂直制表符\n- `\\w`：匹配一个单字字符，等价于 [A-Za-z0-9_]\n- `\\W`：匹配一个非单字字符，等价于 [^A-Za-z0-9_]\n\n\n","timeToRead":1}},{"node":{"id":"031e3d0b-178b-5d27-9d79-eb80307e4a66","frontmatter":{"title":"JavaScript 最佳实践","date":"2016/08/31","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016083125"},"excerpt":"翻译自： JavaScript Best Practices: Tips & Tricks to Level Up Your Code \n没有严格的按照原文翻译，删减修改了部分内容。 在这个教程中，会列出一些重要的 JavaScript 的最佳实践，学习这些并不会很困难。 避免…","rawMarkdownBody":"\n> 翻译自：[JavaScript Best Practices: Tips & Tricks to Level Up Your Code](https://www.codementor.io/javascript/tutorial/javascript-best-practices)\n> 没有严格的按照原文翻译，删减修改了部分内容。\n\n在这个教程中，会列出一些重要的 JavaScript 的最佳实践，学习这些并不会很困难。\n\n## 避免污染全局作用域\n声明变量是很有趣的，有时候你会在你不知情的情况下声明了全局变量。在现在的浏览器中，全局变量将会存储在 `window` 变量中。在全局作用域中的变量可能在不经意间被覆盖。\n\n<!--more-->\n\n假设你现在有一个 HTML 文件，其中包括一个 `<script>` 标签，包含如下内容：\n\n``` js\nvar foo = 42;\nconsole.log(foo);\n```\n\n显然这会在控制台中输出 42。但是，由于这些代码不是在函数中执行的，而是处于全局作用域中，因此 foo 将会被附加到 `window` 上。也就是说 `window.foo` 的值同样也是 42。\n\n这样做是危险的，因为这样会覆盖现有的全局变量。\n\n``` js\nfunction print () {\n  // do something\n}\nprint();\n```\n\n当执行 `window.print` 或者 `print` 时，因为我们重写了 `print` 函数，所以原来的打印函数不起作用了，也就不会弹出打印框了。\n\n解决办法很简单：使用立即执行函数（IIFE）。\n\n``` js\n// Declare an anonymous function\n(function () {\n   var foo = 42;\n   console.log(window.foo);\n   // → undefined\n   console.log(foo);\n   // → 42\n})();\n//^ and call it immediately\n```\n\n或者，可以将 `window` 等全局变量作为参数传递给函数（这可能提高性能）：\n\n``` js\n(function (global, doc) {\n  global.setTimeout(function () {\n     doc.body.innerHTML = \"Hello!\";\n  }, 1000);\n})(window, document);\n```\n\n所以，我们可以使用上述的两种方式，避免不知情的情况下创建全局变量。\n\n## 使用 \"use strict\"\n严格使用 `\"use strict\"`，这只不过是在你的代码中添加字符串，但它的作用非常大。\n\n比如：\n\n``` js\n// This is bad, since you do create a global without having anyone to tell you\n(function () {\n   a = 42;\n   console.log(a);\n   // → 42\n})();\nconsole.log(a);\n// → 42\n```\n\n上述代码，如果使用 `\"use strict\"`，你将会得到一些错误信息：\n\n``` js\n(function () {\n   \"use strict\";\n   a = 42;\n   // Error: Uncaught ReferenceError: a is not defined\n})();\n```\n\n你可能会很奇怪，为什么不把 `\"use strict\"` 放到函数之外？实际上你可以将它放到函数外，但是这样的话他就在全局环境中应用了。这有可能影响来自其他库的代码。\n\n## 使用 ===\n如果你比较 a 和 b 时使用 `==`，在 JavaScript 中你会发现这是一种奇怪的方式。如果你有一个字符串和一个数字，像是下面这样。他们将是相等的，即返回 true：\n\n``` js\n\"42\" == 42\n// → true\n```\n\n这是一种不严格的比较，在进行数据验证时，最好使用 `===`。这将会严格的比较 a 与 b 是否相等：\n\n``` js\n\"42\" === 42\n// → false\n```\n\n## 使用神奇的 && 和 ||\n根据的你的需要，可以使用逻辑运算符使得代码更加简短。例如：\n\n``` js\n\"\" || \"foo\"\n// → \"foo\"\n\nundefined || 42\n// → 42\n\n// Note that if you want to handle 0 there, you need\n// to check if a number was provided:\nvar a = 0;\na || 42\n// → 42\n\n// This is a ternary operator—works like an inline if-else statement\nvar b = typeof a === \"number\" ? a : 42;\n// → 0\n```\n\n可以这样简单的实现 if 的检查：\n\n``` js\nexpr && doSomething();\n\n// Instead of:\nif (expr) {\n   doSomething();\n}\n```\n\n如果你需要返回结果，你还可以这样做：\n\n``` js\nfunction doSomething () {\n   return { foo: \"bar\" };\n}\nvar expr = true;\nvar res = expr && doSomething();\nres && console.log(res);\n// → { foo: \"bar\" }\n```\n\n这里你可以不同意我的观点，但这是比较理想的情况。如果你不想要这样丑化你的代码，使得代码隐晦。这是那些 JavaScript 压缩工具会做的事情，你可以使用它们。\n\n虽然代码比较短，但是这依然是具有可读性的。\n\n## 转换类型\n有很多种方式去进行类型转换，要怎么转换取决于你。这里有一些常用的方法：\n\n``` js\n// From anything to a number\n\nvar foo = \"42\";\nvar myNumber = +foo; // shortcut for Number(foo)\n// → 42\n\n// Tip: you can convert it directly into a negative number\nvar negativeFoo = -foo; // or -Number(foo)\n// → -42\n\n// From object to array\n// Tip: `arguments` is an object and in general you want to use it as array\nvar args = { 0: \"foo\", 1: \"bar\", length: 2 };\nArray.prototype.slice.call(args)\n// → [ 'foo', 'bar' ]\n\n// Anything to boolean\n/// Non non p is a boolean p\nvar t = 1;\nvar f = 0;\n!!t\n// → true\n!!f\n// → false\n\n/// And non-p is a boolean non-p\n!t\n// → false\n!f\n// → true\n\n// Anything to string\nvar foo = 42;\n\"\" + foo // shortcut for String(foo)\n// → \"42\"\n\nfoo = { hello: \"world\" };\nJSON.stringify(foo);\n// → '{ \"hello\":\"world\" }'\n\nJSON.stringify(foo, null, 4); // beautify the things\n// →\n// '{\n//    \"hello\": \"world\"\n// }'\n\n// Note you cannot JSON.stringify circular structures\nJSON.stringify(window);\n// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.\n```\n\n## 代码风格\n对新项目，保持项目中的所有代码的风格相同。对于现有项目，使用现有项目的代码风格，除非你真的想去改变它。\n\n**制定你的代码风格，并始终遵循它**\n\n这里还有一些推荐的现有代码风格：\n\n- [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n- [airbnb/javascript](https://github.com/airbnb/javascript)\n\n\n","timeToRead":3}},{"node":{"id":"bbe1efba-433d-55c5-85f1-ecdef61c19fe","frontmatter":{"title":"如何减少浏览器回流","date":"2016/08/02","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016080224"},"excerpt":"什么是浏览器回流 浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。 触发浏览器回流的操作： 在 DOM 中插入，移除或者…","rawMarkdownBody":"\n## 什么是浏览器回流\n浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。\n\n触发浏览器回流的操作：\n- 在 DOM 中插入，移除或者更新元素\n- 修改页面上的内容\n- 移动 DOM 元素\n- 修改元素 CSS 样式\n- 修改元素的类名\n- 调整窗口的大小\n\n<!--more-->\n\n基本上跟元素相关的操作都会触发浏览器回流。浏览器的回流需要耗时，尽量减少浏览器的回流，那么就可以提高整个网页的效率。\n\n## 创建单一元素\n当我们需要创建一个新元素插入到页面中，并且设置元素的属性。我们会这样做：\n\n``` js\nfunction addElement(parent, elementText) {\n  var element = document.createElement('a');\n  parent.appendChild(element);\n  element.innerHTML = anchorText;\n}\n```\n\n这样写会产生2次浏览器回流，新创建的元素在插入页面中之后又进行了属性的修改。更好的写法是把插入到页面的操作放到最后，这样给元素设置属性的操作就是在内存中进行的。这样就只有元素插入到页面时产生的一次回流。\n\n``` js\nfunction addElement(parent, elementText) {\n  var element = document.createElement('a');\n  element.innerHTML = anchorText;\n  parent.appendChild(element);\n}\n```\n\n## 创建多个元素\n在实际的使用中，更多的情况是创建多个元素，并插入到页面中。按照创建单一元素插入到页面时的写法，我们会这样写：\n\n``` js\nfunction addElements(parent, elementText) {\n  var element;\n\n  for (var i = 0; i < 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    parent.appendChild(element);\n  }\n}\n```\n\n可以看出，这样写会产生10次回流，每一次插入元素都会产生一次。这时候我们需要用到 [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)，DocumentFragment 有占位符的作用，可以暂时存放那些插入文档元素。\n\n当把一个 DocumentFragment 插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。可以用 `Document.createDocumentFragment()` 方法创建新的空 DocumentFragment 节点。\n\n通过 DocumentFragment 可以让上面的操作值产生一次浏览器回流：\n\n``` js\nfunction addElements(parent, elementText) {\n  var element,\n      fragment = document.createDocumentFragment();\n\n  for (var i = 0; i < 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    fragment.appendChild(element);\n  }\n\n  parent.appendChild(fragment);\n}\n```\n## 修改元素样式\n\n在 JavaScript 中修改元素的样式也是经常会做的操作。修改元素的多个样式时会这样：\n\n``` js\nfunction changeStyle(element) {\n  element.style.fontSize   = \"14px\";\n  element.style.fontWeight = \"600\";\n  element.style.color      = \"#fff\";\n}\n```\n\n实际上，每一次对元素的样式的变更都会产生一次回流。好的做法是创建一个 class 包含这些样式。\n\n``` css\n.changeStyle {\n  font-size: 14px;\n  font-weight: 600;\n  color: #fff;\n}\n```\n\n``` js\nfunction changeStyle(element) {\n  element.className = 'changeStyle';\n}\n```\n\n## 总结\n减少浏览器回流的方式，就是将一切能够在内存完成的完成之后再应用到页面中，对元素样式的操作尽量通过添加修改 CSS 类来实现。\n","timeToRead":2}},{"node":{"id":"4e99ab9f-ad3b-5589-afd3-e6401831612c","frontmatter":{"title":"数组乱序的正确姿势","date":"2016/07/25","tags":["JavaScript","前端","Underscore"]},"fields":{"slug":"/posts/2016072523"},"excerpt":"在   中有一个函数，其作用是将数组乱序排序，实现如下： 其中使用的数组乱序的算法是  Fisher–Yates shuffle 。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。 每次循环从前面的   个元素中随机选择一个元素  。将这个元素与第   个元素进行交换，…","rawMarkdownBody":"\n在 `underscore` 中有一个函数，其作用是将数组乱序排序，实现如下：\n\n``` js\n// Shuffle a collection, using the modern version of the\n// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n// `shuffle` 函数。\n_.shuffle = function(obj) {\n  var set = isArrayLike(obj) ? obj : _.values(obj);\n  var length = set.length;\n  var shuffled = Array(length);\n  for (var index = 0, rand; index < length; index++) {\n    rand = _.random(0, index);\n    if (rand !== index) shuffled[index] = shuffled[rand];\n    shuffled[rand] = set[index];\n  }\n  return shuffled;\n};\n```\n<!--more-->\n\n其中使用的数组乱序的算法是 [Fisher–Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。\n\n每次循环从前面的 `index` 个元素中随机选择一个元素 `shuffle[rand]`。将这个元素与第 `index` 个元素进行交换，直到 `index == length` 为止。这样对元素进行随机交换，对于每个结果所获得概率是均匀的。`_.shuffle` 方法是返回一个新的乱序数组，所以需要一个新的数组来存储。\n\n对原有数组进行乱序：\n\n``` js\nfunction shuffle(arr) {\n  var length = arr.length;\n  for (var index = 0, rand; index < length; index ++) {\n    rand = Math.floor(Math.random() * (length - 1));\n\n    var temp = arr[rand];\n    arr[rand] = arr[index];\n    arr[index] = temp;\n  }\n  return arr;\n}\n```\n\n**More**\n- [JavaScript 数组乱序](https://github.com/hanzichi/underscore-analysis/issues/15)\n- [数组的完全随机排列](https://www.h5jun.com/post/array-shuffle.html)\n","timeToRead":1}},{"node":{"id":"b1f068b0-eecb-5931-8ef6-e5ac0e7fdff0","frontmatter":{"title":"Vue 中使用 highlight.js","date":"2016/07/13","tags":["Vue","前端"]},"fields":{"slug":"/posts/2016071321"},"excerpt":"今天遇到一个问题：在使用 vue 的练手项目中，渲染的 HTML 里   标签中的代码没有代码高亮。 遂想到用 highlight.js 来解决，按照平常那样在 HTML 文件中引入   和   文件，然后在  中加上一句  。但是却没有效果。 在 Vue.js 的论坛上找到了…","rawMarkdownBody":"\n今天遇到一个问题：在使用 vue 的练手项目中，渲染的 HTML 里 `<code>` 标签中的代码没有代码高亮。\n\n遂想到用 highlight.js 来解决，按照平常那样在 HTML 文件中引入 `js` 和 `css` 文件，然后在`<header>` 中加上一句 `<script>hljs.initHighlightingOnLoad();</script>`。但是却没有效果。\n\n在 Vue.js 的论坛上找到了解决方案 [Getting highlightjs to work with vue-router](https://forum.vuejs.org/topic/3514/getting-highlightjs-to-work-with-vue-router)。highlight.js 没有效果是因为使用了 `vue-route`，在 route 改变时，页面将会重新渲染并且会移除事件，这里就把 highlight 的事件给移除了。\n<!--more-->\n\n## Solution\n所以得到的解决方案是，使用 Vue.js 的自定义指令，定义一个叫做 `v-highlight` 的指令来使得 `<pre><code> .. </code></pre>` 中的代码高亮。\n\n定义自定义指令：\n``` js\nimport Hljs from 'highlight.js'\n\nVue.directive('highlightjs', function() {\n  let blocks = this.el.querySelectorAll('pre code');\n  Array.prototype.forEach.call(blocks, Hljs.highlightBlock);\n})\n```\n\n这里 import 了 highlight.js，所以需要 `npm install highlight.js`。导入之后使用 `Vue.directive()` 定义 `v-highlightjs` 指令，获取使用该指令的 document 中的 `pre  code` 部分，并使用 highlight.js 的 `highlightBlock` 使其高亮。\n\n## How to use\n之后在需要高亮的地方，使用 `v-highlightjs` 指令即可用使得其中的 `<pre><code> .. </code></pre>` 部分高亮。\n\n``` html\n<div v-html=\"your_content\" v-highlightjs>\n</div>\n```\n","timeToRead":1}},{"node":{"id":"40578614-d86c-54a9-bb8b-95841a04e704","frontmatter":{"title":"CSS 实现垂直居中","date":"2016/06/29","tags":["CSS","前端"]},"fields":{"slug":"/posts/2016062921"},"excerpt":"我们有这样一个结构的 HTML： 如果我们要实现   在   中垂直居中。 通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过   与   各偏移 50% 父元素宽度，使用   来修正子元素的位置。 通过这种方式可以使得子元素在父…","rawMarkdownBody":"\n我们有这样一个结构的 HTML：\n\n``` html\n<div class=\"parent\">\n  <div class=\"children\"></div>\n</div>\n```\n\n如果我们要实现 `.children` 在 `.parent` 中垂直居中。\n\n通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过 `top` 与 `left` 各偏移 50% 父元素宽度，使用 `margin-*` 来修正子元素的位置。\n<!--more-->\n\n``` css\n.parent {\n  position: relative;\n}\n\n.chilren {\n  width: $width;\n  height: $height;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  margin-top: -$height/2;\n  margin-left: -$width/2;\n}\n```\n\n通过这种方式可以使得子元素在父元素中垂直居中。但是这种实现的方式需要知道子元素的宽高，以方便使用 `margin-*` 来修正之前的位置。\n\n当不知道子元素的宽高时，这种方法就无法实现正真的垂直居中。这个时候就可以使用 `transform: translate(-50%, -50%);` 来实现子元素自身的偏移。\n\n``` CSS\n.parent {\n  position: relative;\n}\n\n.chilren {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n那么不使用定位是否能够使元素垂直居中呢？\n\n这时候我们来想想要使元素水平居中的时候，我们会怎么做？Ok，一般我们都会用 `margin: 0 auto`;那么我们就可以让 `margin-top: 50%`, 这样的效果就跟相对定位时的 `top: 50%` 的效果差不多。接着就可以使用之前使用过的 `transform` 属性来使得元素向上偏移自身高度的一半，也就是 `transform: translateY(-50%);`。\n\n这样就可以实现不使用定位来来使得元素垂直居中了。\n\n``` CSS\n.chilren {\n  margin: 50% auto 0;\n  transform: translateY(50%);\n}\n```\n\n除了上面的这些方法之外，还可以使用 Flexbox 布局来实现。\n\n只需要在父元素中使用 `display: flex;`，然后在子元素上使用 `margin: auto;` 就可以实现垂直居中了。\n\n``` CSS\n.parent {\n  display: flex;\n}\n\n.chilren {\n  margin: auto;\n}\n```\n\n另外还有几种实现垂直居中的方法，并不常见与常用，使用就不提了。\n","timeToRead":1}},{"node":{"id":"70912961-33b4-5e44-b636-177db09c8caa","frontmatter":{"title":"Sass 初探","date":"2016/06/07","tags":["CSS","Sass"]},"fields":{"slug":"/posts/2016060720"},"excerpt":"为什么学 Sass 说起来其实很早就知道   这东西。刚开始写 Even 这个博客主题的时候就有在考虑是要用   还是 ，最后用了变量名用   开头的 Less（可能是 PHP 的原因，对   开头的变量名没什么好感）。 最近正在看  ，源码是用 Sass 写的。  之前也是用…","rawMarkdownBody":"\n## 为什么学 Sass\n\n说起来其实很早就知道 `Sass` 这东西。刚开始写 Even 这个博客主题的时候就有在考虑是要用 `Less` 还是`Sass`，最后用了变量名用 `@` 开头的 Less（可能是 PHP 的原因，对 `$` 开头的变量名没什么好感）。\n\n最近正在看 `Foundation`，源码是用 Sass 写的。`Bootstrap` 之前也是用 Less 的，不过后来也转向了 Sass。然后发现 `Foundation` 写得挺不错的，看看博客主题写的代码，简直不能看。正好打算把主题给重构重构，就顺手学学 Sass，用 Sass 写。\n<!--more-->\n\n## Sass 是什么\n\nSass 是CSS的扩展，增加了规则嵌套、变量、混合、选择器继承等等，通过使用命令行的工具把它转换成CSS代码，能够更编程语言化的写 CSS。\n\nSass 有两种语法，`Sass` 与 `SCSS`。`Sass` 使用的是类似于 Python 的缩进语法，而 `SCSS` 使用的语法与 CSS 相近，只是添加了一些其他的东西，可以看做是 CSS 超集。\n\nPS: 使用 `SCSS` 语法的文件后缀是 `SCSS` （一定是大写）。\n\n## SCSS 语法\n\n### 变量\n上面说了，刚开始我不用 Sass 的原因就是变量名是以 `$` 开头的。与 Less 不同的是，Sass 的变量赋值使用的是 `:`，跟 CSS 的属性赋值相同。\n\n```scss\n// sass style\n$fontSize: 14px;\nspan {\n  font-size: $fontSize;\n}\n\n// css style\nspan {\n  font-size: 14px;\n}\n```\n\nSass 还支持多值变量，list 类型与 map 类型，与 JavaScript 中的 list, map 相似。\n\nlist 类型可以使用 `nth($list, $index)` 来取得 list 中的某个值，相同的 map 也有对应的取值的函数：`map-get($map, $key)`。\n\nlist 类型：\n```scss\n// sass style\n$color-list: #fff, #000;\na {\n  color: nth($color-list, 1);\n\n  &:hover {\n    color: nth($color-list, 2);\n  }\n}\n```\n\nmap 类型：\n```scss\n// sass style\n$color-map: (\n  white: #fff,\n  black: #000\n);\na {\n  color: map-get($color-map, white);\n\n  &:hover {\n    color: map-get($color-map, black);\n  }\n}\n```\n\n### 嵌套\n与大部分 CSS 预处理器相同，Sass 也支持层级嵌套。这样可以更好的表示 CSS 的层级关系。\n\n```scss\n// sass style\nul {\n  margin: 5px;\n\n  li {\n    list-style: none;\n  }\n}\n\n// css style\nul {\n  margin: 5px;\n}\n\nul li {\n  list-style: none;\n}\n```\n\n### 混合\nSass 中使用 `@mixin` 声明混合，可以传递参数，多个参数以逗号分开，也可以给参数设置默认值。声明的@mixin通过@include来调用。\n\n```scss\n//sass style\n@mixin center-block {\n    margin-left:auto;\n    margin-right:auto;\n}\n.demo{\n    @include center-block;\n}\n\n//css style\n.demo{\n    margin-left:auto;\n    margin-right:auto;\n}\n```\n\n### 条件与循环\n一般的 CSS 是没有条件与循环的，拥有了条件与循环语句的 Sass 更加的灵活，可以使得 CSS 样式根据变量而改变。\n\n#### 条件\nSass 中的条件语句为 `@if` 与 `@else`, 可以组合成为 `@else if`。\n```scss\n// sass style\n$color: white;\np {\n  @if $color == white {\n    color: #fff;\n  }\n  @else {\n    color: #000;\n  }\n}\n\n// css style\np {\n  color: #fff;\n}\n```\n\n#### 循环\nfor循环有两种形式，分别为：`@for $var from <start> through <end>` 和 `@for $var from <start> to <end>`。`through` 与 `to` 的区别是循环包不包括 `<end>`。\n\n```scss\n// sass style\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n\n// css style\n.item-1 {\n  width: 2em;\n}\n.item-2 {\n  width: 4em;\n}\n.item-3 {\n  width: 6em;\n}\n```\n\neach循环语法为：`@each $var in <list or map>`，与 JavaScript 中的 `each` 类似，即是遍历 list 或者 map。\n\n```scss\n// sass style\n$color-list: red green yellow;\n@each $color in $color-list {\n  .#{$color} {\n    color: $color;\n  }\n}\n\n// css style\n.red {\n  color: red;\n}\n.green {\n  color: green;\n}\n.yellow {\n  color: yellow;\n}\n```\n","timeToRead":3}},{"node":{"id":"05e1d982-d6d2-5a2c-98dc-aad63af5d312","frontmatter":{"title":"使用 Nokogiri 解析 HTML","date":"2016/05/28","tags":["Ruby"]},"fields":{"slug":"/posts/2016052819"},"excerpt":"Nokogiri 是 Ruby 的一个 HTML/XML 文件的解析库。在需要解析 HTML/XML 文件获取数据时，它是一个很好的选择。 解析 HTML 文档 使用   解析 HTML 将会生成  。\n生成该对象的方式有三种，分别是通过字符串解析，通过文件解析，通过网络解析。…","rawMarkdownBody":"\nNokogiri 是 Ruby 的一个 HTML/XML 文件的解析库。在需要解析 HTML/XML 文件获取数据时，它是一个很好的选择。\n\n## 解析 HTML 文档\n使用 `Nokogiri` 解析 HTML 将会生成 `Nokogiri documens`。\n生成该对象的方式有三种，分别是通过字符串解析，通过文件解析，通过网络解析。\n\n### 通过字符串解析\n通过字符串解析，即是将字符串当作函数的参数传给 `Nokogiri::HTML` 函数。\n```ruby\ndoc = Nokogiri::HTML(\"<html><body><h1>Ahonn</h1></body></html>\")\n```\n<!--more-->\n\n### 通过文件解析\n通过文件解析需要打开文件，并将文件内容当作参数。\n```ruby\ndoc = File.open(\"index.html\") { |f| Nokogiri::HTML(f) }\n```\n\n### 通过网络解析\n这是最常用的形式，即使用 `open-uri` 打开对应的网址，并返回字符串给 `Nokogiri`。\n```ruby\nrequire \"open-uri\"\ndoc = Nokogiri::HTMl(open(\"http://www.ahonn.me\"))\n```\n\n## 搜索 HTML 文档\nNokogiri 提供 xpath 以及 css 选择器这两种方式来搜索 HTML 文档，使得我们能够获取到对应的需要的节点及数据。\n\n`xpath` 方法以及 `css` 方法返回的是一个节点结果集。\n\n```ruby\ndoc = Nokogiri::HTML(open(\"http://www.ahonn.me\"))\n\ndoc.xpath(\"//title\")\n\ndoc.css(\".nav-list a\")\n\n# ['<a href=\"/\" target=\"_self\" class=\"nav-list-link active\">Home</a>',\n# '<a href=\"/archives/\" target=\"_self\" class=\"nav-list-link\">Archives</a>',\n# '<a href=\"/tags/\" target=\"_self\" class=\"nav-list-link\">Tags</a>',\n# '<a href=\"/about/\" target=\"_self\" class=\"nav-list-link\">About</a>']\n```\n### 获取单个结果\n如果想要返回单个结果，可以使用 `at_xpath` 或者 `at_css` 方法来获取结果集中的第一个元素。\n就是说返回的不再是结果集，而是元素节点。\n\n```ruby\ndoc.at_css(\".nav-list a\")\n# <a href=\"/\" target=\"_self\" class=\"nav-list-link active\">Home</a>\n```\n### 获取元素属性\n还可通过 `.` 或者索引来获取元素的属性：\n```ruby\nlinks = doc.css(\".nav-list a\")\n\nputs links.length # 4\nputs links[0].text # Home\nputs links[1]['href'] # /archives/\n```\n\n### 限制选择器\nNokogiri 还提供了自定义筛选的限制选择器，返回结果集中符合条件的元素：\n```ruby\nlinks = doc.css(\".nav-list a\").select{ |link| link['href'] == \"/archives/\" }\n\nlinks.each { |link| puts link.text }  # Archives\n```\n","timeToRead":2}},{"node":{"id":"3da259de-69e4-5394-9c67-14267b4c2d2e","frontmatter":{"title":"使用 JavaScript 实现简单的拖拽","date":"2016/05/14","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016051418"},"excerpt":"步骤 使用 JavaScript 实现拖拽的步骤： 让元素捕获事件（mousedown, mousemove & mouseup） 单击并不释放，触发 mousedown，标记开始拖拽，并获取元素和鼠标的位置 拖动鼠标，触发 mousemove，不断的获取鼠标的位置，并通过计算…","rawMarkdownBody":"\n## 步骤\n\n使用 JavaScript 实现拖拽的步骤：\n- 让元素捕获事件（mousedown, mousemove & mouseup）\n- 单击并不释放，触发 mousedown，标记开始拖拽，并获取元素和鼠标的位置\n- 拖动鼠标，触发 mousemove，不断的获取鼠标的位置，并通过计算重新确定元素的位置\n- 释放师表，触发 mouseup，结束拖拽，确定元素位置并更新\n\n**被拖拽的元素必须是相对父元素定位，或者是绝对定位**\n\n<!--more-->\n\n## 实现\n\n### 绑定事件\n\n首先，对拖拽的元素绑定 mousedown 时间，使其触发对应的函数，获取元素与鼠标的位置。在 document 对象上绑定 mousemove 和 mouseup 事件，不在拖拽的元素上绑定是因为当鼠标移动太快而超出元素的范围时会停止拖拽，而绑定在 document 上则可以避免这样的事情发生。拖拽再快都不会超出 document 的范围。\n\n绑定事件：\n```js\nvar box = document.getElementById('box');\n\nbox.onmousedown = down;\ndocument.onmousemove = move;\ndocument.onmouseup = up;\n```\n\n## 获取鼠标位置\n\n鼠标位置可以在 event 对象中获得，常用的属性有：\n- clientX / clientY : 相对浏览器窗口坐标\n- offsetX / offsetY : 相对事件目标对象坐标\n- pageX / pageY : 相对 document 对象坐标\n\n一般鼠标的位置使用 `pageX / pageY` 获取，但是 IE 不支持这两个属性。所以在 IE 中使用 `event.clientX + document.body.scrollLeft - document.body.clientLeft;` 获取鼠标的位置。\n\n获取鼠标位置的函数：\n```js\nfunction getMouseXY(e) {\n  var x = 0, y = 0;\n  e = e || window.event;\n  if (e.pageX) {\n    x = e.pageX;\n    y = e.pageY;\n  } else {\n    x = e.clientX + document.body.scrollLeft - document.body.clientLeft;\n    y = e.clientY + document.body.scrollTop - document.body.clientTop;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n```\n\n### 事件触发函数\n#### mousedown\n\n当鼠标移动到元素内并点击元素不放时，触发 mousedown 事件。按照上面的步骤，这一步是获取元素与鼠标的位置，用于触发 mousemove 时计算元素的位置。\n\nmousedown 触发的函数：\n```js\nfunction down(e) {\n  dragging = true;\n  boxX = box.offsetLeft;\n  boxY = box.offsetTop;\n  mouseX = parseInt(getMouseXY(e).x);\n  mouseY = parseInt(getMouseXY(e).y);\n  offsetX = mouseX - boxX;\n  offsetY = mouseY - boxY;\n}\n```\n\n`boxX / boxY` 为元素左上角相对于已定位的父元素（相对或者绝对定位的父元素）的偏移的像素值，即元素左上角的坐标。\n\n`mouseX / mouseY` 是通过 `getMouseXY` 函数获得的鼠标的坐标。\n\n`offsetX/ offsetY` 是鼠标相对于元素坐标（左上角坐标）的坐标。\n\n#### mousemove\n\n当鼠标移动时，不断的获取鼠标的位置，并计算元素的新坐标修改元素的位置样式。\n\n```js\nfunction move(e) {\n  if (dragging) {\n    var x = getMouseXY(e).x - offsetX;\n    var y = getMouseXY(e).y - offsetY;\n    var width = document.documentElement.clientWidth - box.offsetWidth;\n    var height = document.documentElement.clientHeight - box.offsetHeight;\n\n    x = Math.min(Math.max(0, x), width);\n    y = Math.min(Math.max(0, y), height);\n\n    box.style.left = x + 'px';\n    box.style.top = y + 'px';\n  }\n}\n```\n\n变量 `width / height` 表示可移动的位置的大小，这里是 document 减去元素的大小（元素不会超出可移动的范围）。\n\n`Math.min` 使得元素不会超出可移动访问的右边界（元素 x 坐标不会超过 width），`Math.max` 使得元素不会超出可移动范围的左边界（元素的 x 坐标不小于 0）。\n\n最后将改变后的元素 `left` 与 `top` 值应用当元素上，即修改元素的样式。\n\n#### mouseup\n\n拖拽结束，取消拖拽的标记。使其触发 mousemove 事件，但不做任何处理。\n\n```js\nfunction up(e) {\n  dragging = false;\n}\n```\n\n## 总结\n上面使用的简单的 JavaScript 代码实现了元素的拖拽，但并没有对兼容性问题全面考虑，也没有对性能优化，有不必要的事件触发。\n","timeToRead":2}},{"node":{"id":"ea597adb-58f2-5c2d-8691-c405bbeaccae","frontmatter":{"title":"记第一次面试","date":"2016/05/14","tags":["面试"]},"fields":{"slug":"/posts/2016051417"},"excerpt":"记录第一次面试 流水账 想到什么写什么 第一次正正经经的去面试，虽然只是个软件开发暑期实习生。 刚开始是在网上无聊的逛 V2EX 什么的，然后看了看 conde 社区。后来神不知鬼不觉的不知道为什么就跑到了 Ruby China 去了，又神不知鬼不觉的跑去看了招聘的版块。 其实…","rawMarkdownBody":"\n> 记录第一次面试 流水账 想到什么写什么\n\n第一次正正经经的去面试，虽然只是个软件开发暑期实习生。\n\n刚开始是在网上无聊的逛 V2EX 什么的，然后看了看 conde 社区。后来神不知鬼不觉的不知道为什么就跑到了 Ruby China 去了，又神不知鬼不觉的跑去看了招聘的版块。\n\n其实在这之前的两个星期都有在拉钩上投实习，虽然有几个简历通过了，但是却毫无沟通的直接定了面试时间。不是刚刚好顶到上课时间，就是早上 10 点的（也就是说我得早上 7 点起床赶去广州面试）。说实在的对那些公司兴趣也不是很大。\n<!--more-->\n\n后来就如上所说的，在逛 Ruby China 招聘板块的时候，看到了广州的一家公司招暑假实习生的帖子。遂留言问问看招不招大二的，说是招大二的。看了看条件，感觉也好像没有什么条件，大概是大二吧，可能就是对技术有兴趣，自学能力强一点的就 OK 了。跟之前拉钩上投的公司不一样，不会感觉很单调死板看不到特色。帖子贴了很多照片，感觉是一群很有趣的人，应该是个实习的好去处呢。\n\n说是要中英文简历，那时候正好也刚写好了在线简历，不过倒是没有英文版呢。一直惦记着要投简历去那家公司，但是又一直拖啊拖的没有去写英文版。大概拖了 3 天，那天下午把英文的给加上了，然后就简历发过去了。之后那边回了邮件，还是用的英文回的。说是什么现在在越南，五月初回来广州会联系我。回英文邮件还真是头疼，纠结了大半天。\n\n然后就是等啊等啊等啊。\n\n上周接了该公司一个姐姐的电话，问我说下周什么时候有空面试。然后我很果断的说了下周三（我忘记了下周补课这回事了），挂了电话之后直接懵逼了。。。光这点就给好评了，那些直接定时间真的让我好难办啊。后面到了面试的那天，本来打算早上上完课吃完饭就直接出发的，可是肚子这个时候不舒服，回了下宿舍。结果就错过了本来计划好的那班公交车，坐了下一班，导致面试迟到了，妈个鸡。\n\n面试地点本来是在公司的，后面说是隔壁装修声音太大，改到了一个小咖啡馆里。话说这咖啡馆还真是难找，绕了两圈才找到。进门看见两个人用着 Macbook 写代码，应该是面试官了（因为没有其他人了）。接着就是先做一个钟的笔试题，拿到的瞬间有点懵逼...居然是全英文的...不过还好平时也有看看英文的文档什么的，看得懂七七八八。Ruby 跟 Rails 部分几乎不会，只过了一遍 Rails Guides 里的入门教程。然后 JavaScript 也是挺懵逼的，都是用 JQuery（果然还是得去搞搞 jQuery 啊）。最后面也只是写了个实现其他编程语言中的 pow 函数，可能是太紧张了，忘记考虑指数为负的情况了。好弱鸡...还有用 jQuery 实现 DOM 拖拽的，瞄过几眼，但是压根没办法直接写出来啊，找个时间的好好看看。\n\n手写代码果然还是觉得好别扭...\n\n笔试真的是绝对的懵逼，我给自己打 20 分。不过后面面试倒是很轻松，感觉好像没问什么东西，纯瞎聊得感觉。不过说得很对，我的确是缺个能带的人。虽然自己有一些想法，但是总是没办法起手开搞。那些所谓的项目也都是自己觉得好玩搞的，都没有一个算是实实际际的项目的。\n\n总结一下面试，就是从笔试题跟简历入手去问。好像面试我的时候没问什么东西，面试过程倒是挺愉快的。不过感觉招大二的话好像不是很看重笔试题，跟看重对技术的热情？毕竟 Ruby 什么的是可以学的。\n\n昨天小伙伴 yzz 也去那里面试，不过面试地点这一次就没有改了。正好下午也只是一节体育课，就跟着去了，去看看公司长啥样。第一感觉是家庭小作坊，类似美剧硅谷里面他们的那种环境，感觉很赞啊。要是像正常的公司那样的话，感觉融入感不强。这样的地方实习感觉会很开心啊。Boss 是个黑人，工位也和普通员工一样。yzz 做笔试题的时候好像听到 Boss 说什么什么 coding 什么的，Boss 好像也是撸代码的呢，不错。每个人的工作环境就是理想中的那样，外接大屏幕，舒服的椅子，有些有机械键盘，这样的编码环境完美。\n\n哦，对了。好像刚进去的时候有一股榴莲味，估计是中午的饭后水果呢。比较自由的感觉，给人一种小家庭的feel。不过面试过程好像比面试我要问得多，小伙伴也可能因为紧张，原来懂得东西都不知道该怎么说了，我都替他紧张了。倒是面试过程也不是很严肃，面试官换了一个，不过也觉得挺 nice 的。面试完之后一个姐姐带着我们逛了一下里面（应该是打电话发邮件确定面试的那位？），然后就走啦。走的时候他们都坐在沙发上聊天吃东西呢好像，越来越觉得 nice 了。要是能通过的话估计实习会收获很多啊，不管什么方面。\n\n流水账般的写完了，小学语文水平...天...\n","timeToRead":1}},{"node":{"id":"06883114-c1a8-53e6-b524-f259acd65ee6","frontmatter":{"title":"从 optimizeCb 说起","date":"2016/05/03","tags":["JavaScript","前端","Underscore"]},"fields":{"slug":"/posts/2016050316"},"excerpt":"optimizeCb 在   中的内部函数  ，顾名思义就是 optimize callback，即优化回调函数。 optimizeCb: 它是这样处理回调的，当回调函数指定上下文环境时，根据   来分情况使用  ，不同情况的\n区别只是   除了上下文环境之外的函数参数的个数不…","rawMarkdownBody":"\n## optimizeCb\n在 `underscore` 中的内部函数 `optimizeCb`，顾名思义就是 optimize callback，即优化回调函数。\n\noptimizeCb:\n\n```js\n// Internal function that returns an efficient (for current engines) version\n// of the passed-in callback, to be repeatedly applied in other Underscore\n// functions.\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    // The 2-parameter case has been omitted only because no current consumers\n    // made use of it.\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n```\n\n<!--more-->\n它是这样处理回调的，当回调函数指定上下文环境时，根据 `argCount` 来分情况使用 `call`，不同情况的\n区别只是 `call` 除了上下文环境之外的函数参数的个数不同。\n\n除了参数个数为 1，3，4 使用 `call` 之外，其他情况使用 `apply`。这里原本存在的参数个数为 2 的\n情况被删除了，原因是因为参数为 2 个的情况在 `underscore` 中基本没有。就是说，对于常用的情况\n使用 `call`，而不常用的使用 `apply`。\n\n那么是不是 `call` 的性能相较于 `apply` 更好呢？\n\n## call 与 apply 的性能\n使用 `optimizeCb` 与只使用 `apply` 的 `Cb` 进行比较\n\n```js\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\n\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n\nvar Cb = function(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  }\n};\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nsuite\n  .add('optimizeCb', function() {\n    optimizeCb(sum, this, 3)(24, 24, 24);\n  })\n  .add('Cb', function() {\n    cb(sum, this)(24, 24, 24);\n  })\n  .on('cycle', function(event) {\n  console.log(String(event.target));\n  })\n  .on('complete', function() {\n    console.log('Fastest is ' + this.filter('fastest').map('name'));\n  })\n  .run({ 'async': true });\n```\n\n测试结果：\n```\noptimizeCb x 16,373,430 ops/sec ±0.93% (80 runs sampled)\ncb x 8,729,305 ops/sec ±1.12% (90 runs sampled)\nFastest is optimizeCb\n```\n\n得出 `call` 在知道参数个数的时候比使用 `apply` 效率更高的结论。\n通过搜索，找到了一篇 [call和apply性能对比](http://blog.csdn.net/zhengyinhui100/article/details/7837127)。\n\n更严谨的说法是，当有this指向或者执行参数时，call的性能要明显优于apply。\n\n## 结论\n所以在编程过程中，如果要使用到 `call` 或者 `apply`，在知道参数个数的情况下，使用 `call` 是\n一个好选择，使得编译器能够去优化。\n","timeToRead":2}},{"node":{"id":"0c642ef5-247c-59ec-bd8a-684edaffc579","frontmatter":{"title":"不合常理的变量提升","date":"2016/04/28","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016042815"},"excerpt":"变量提升 合乎常理的预期 按照合乎常理的预期，程序应该是由上至下一行一行执行的，如果使用了之前没有定义的变量的话，正确的反应应该是会报错，就象下面这段 C++ 代码： 并不完全正确 实际上合乎常理的预期并不是“完全正确”的，在 JavaScript 中并不符合直觉。 例如这段 …","rawMarkdownBody":"\n## 变量提升\n\n### 合乎常理的预期\n按照合乎常理的预期，程序应该是由上至下一行一行执行的，如果使用了之前没有定义的变量的话，正确的反应应该是会报错，就象下面这段 C++ 代码：\n```cpp\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  printf(\"%d\\n\", &n);  // Error\n\n  int n = 2;\n}\n```\n<!--more-->\n\n### 并不完全正确\n实际上合乎常理的预期并不是“完全正确”的，在 JavaScript 中并不符合直觉。\n\n例如这段 JavaScript 代码：\n\n```js\nconsole.log(n);\n\nvar n = 2；\n```\n\n讲道理，就直觉来说这段代码应该是会报错的。但是 JavaScript 却不是像往常的其他编程语言一样报错，而是输出 undefined。\n\n先把问题留着，再看看另一段代码。\n\n```js\nvar n;\n\nconsole.log(n);\n\nn = 2;\n```\n\n这段代码的输出同样也是 undefined，实际上这两段代码在编译器上是没有差别的，第一段代码实际上是按照第二段代码那样执行的。就像是变量的声明部分从原来的位置移动到了当前作用域最顶部，这个过程就叫作 **提升**。只有声明本身会被提升，而赋值操作依旧会留着原地。\n\n## 函数提升\n\n函数在声明时也会像变量一样被提升。但是不同的是，函数表达式不会被提升。\n\n### 函数声明\n\n函数声明提升：\n```js\nfoo();\n\nfunction foo() {\n  console.log(n);\n  var n = 2;\n}\n```\n\n实际上代码将会按照下面的形式执行：\n```js\nfunction foo() {\n  var n;\n  console.log(n);\n  n = 2;\n}\n\nfoo(); // undefined\n```\n\n函数 `foo` 的作用域内的变量 `n` 提升到了作用域的顶部，全局作用域里的 `foo` 函数声明也会被提前到所处的作用域顶部，即全局作用域的顶部。但是函数表达式的话只有变量被声明，但是赋值给变量的函数不会被提升。\n\n### 函数表达式\n\n函数表达式不会被提升：\n```js\nfoo();\n\nvar foo = function bar() {\n  // do something\n}\n```\n\n函数表达式的提升类似与变量的提升：\n```js\nvar foo;\n\nfoo(); // TypeError\n\nfoo = function bar() {\n  // do something\n}\n```\n\n这样会引发 `TypeError` 异常，因为当时的 `foo` 并没有赋值，对 `undefined` 进行函数调用会导致非法操作抛出异常。\n\n### 函数优先\n函数会首先被提升，然后跟着才是变量。也就是说同时存在函数声明与函数表达式时，函数声明会优先于函数表达式提升。\n\n```js\nfoo();\n\nfunction foo() {\n  console.log('1');\n}\n\nvar foo = function () {\n  console.log('2');\n}\n```\n\n上面的代码将会被理解成下面的形式：\n```js\nfunction foo() {\n  console.log('1');\n}\n\nvar foo;\n\nfoo(); // 1\n\nfoo = function () {\n  console.log('2');\n}\n```\n\n所以实际上的输出是 1，因为函数表达式的赋值操作会在原来的位置，而声明操作则是提升到作用域顶部，但是优先级低于函数声明。\n\n重复声明同名变量在 JavaScript 非严格模式中将会被忽略，所以实际上函数表达式的位置并没有改变。\n","timeToRead":2}},{"node":{"id":"39f5d69a-7a4d-5522-b0cf-bf7b84182d3f","frontmatter":{"title":"事件流：冒泡与捕获","date":"2016/04/16","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016041614"},"excerpt":"事件流 事件流描述的是从页面中接收事件的顺序。在 JavaScript 中事件流有两种，一种是由 IE 开发团队提出的事件冒泡流，而另一种是 Netscape 提出的事件捕获流。 事件冒泡 事件冒泡流，即事件开始时由具体的元素接收，然后逐级向上传播，直到 document 对象…","rawMarkdownBody":"\n## 事件流\n事件流描述的是从页面中接收事件的顺序。在 JavaScript 中事件流有两种，一种是由 IE 开发团队提出的事件冒泡流，而另一种是 Netscape 提出的事件捕获流。\n\n### 事件冒泡\n事件冒泡流，即事件开始时由具体的元素接收，然后逐级向上传播，直到 document 对象。\n\n```html\n<div>\n  <p> Click </p>\n</div>\n```\n<!--more-->\n\n上面的例子中，点击 `p` 元素，事件冒泡的顺序是 p > div > body > html > document。\n\n**所有的现代浏览器都支持事件冒泡，部分具体实现不同。**\n\n### 事件捕获\n事件捕获流，即与事件冒泡相反，先在上级元素接收，然后逐级向下传播，直到最具体的元素。（有点像是逐级定位，到最后的元素就是事件冒泡流的起点）\n\n和上面同样的例子，点击 `p` 元素，事件捕获的顺序是 document > html > body > div > p。\n\n**由于老版本不支持，因此很少使用事件捕获。尽量使用事件冒泡。**\n\n### DOM 事件流\n实际上每一次触发事件都会有一个事件流，事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title> Event </title>\n  </head>\n  <body>\n    <div> Cilck </div>\n  </body>\n</html>\n```\n\n即在上面的例子中，事件流包括\n- 事件捕获阶段：document > html > body\n- 处于目标阶段：div\n- 事件冒泡阶段：body > html > document\n\n## 事件处理程序\n添加事件处理程序的方式有 3 种：使用 HTML 的特性，赋值给事件处理程序属性，使用 addEventListener 函数。\n\n### 使用 HTML 的特性\n\n```html\n<input type=\"button\" value=\"Click\" onclick=\"alert('Clicked')\">\n```\n\n这样就是在 HTML 中使用 HTML 中与事件处理程序同名的属性来指定。也可以将该属性的值指向页面中其他地方定义的方法。\n\n通常不建议这样做，这样写的缺点是 HTML 与 JavaScript 紧密耦合，修改起来也麻烦。\n\n### 赋值给事件处理程序属性\n\n这是 JavaScript 中指定事件处理程序的传统方式，将一个函数赋值给事件处理程序属性。\n\n```html\n<input type=\"button\" id=\"btn\" value=\"Click\">\n```\n\n```js\nvar btn = document.getElementById('btn');\nbtn.onclick = function () {\n  alert(\"Clicked\");\n};\n```\n\n这样的效果其实与使用 HTML 特性的例子的作用是相同的，不同的是 JavaScript 指定事件在 js 文件中，这样就与 HTML 解耦了。要删除指定的事件处理程序可以将属性的值设置为 null。\n\n赋值给事件处理程序属性的缺点在与对同一个元素的同一个事件只能添加一个事件处理程序。重复添加相同的事件会覆盖前面所添加的事件。\n\n```js\nbtn.onclick = function () {\n  alert(\"Clicked-01\");\n};\n\nbtn.onclick = function () {\n  alert(\"Clicked-02\");  // 覆盖了上面设置的 onclick 事件\n};\n```\n\n### 使用 addEventListener 函数\n使用 `addEventListener()` 的好处是可以添加多个同一事件的处理程序，不会像使用事件处理程序属性一样覆盖。\n\n`addEventListener()` 有对应的删除事件的方法 `removeEventListener()`，两个方法都接受三个参数。要处理的事件类型（click, blur ...），作为事件处理程序的函数，以及表示是否在捕获阶段调用的布尔值。\n\n#### 添加事件处理程序\n给按钮的 click 事件添加事件处理程序：\n```js\nvar btn = document.getElementById('btn');\nbtn.addEventListener('click', function() {\n  alert(\"click\");\n}, false);\n```\n\n上面为按钮添加了一个 click 事件处理程序，并且该事件会在冒泡阶段被触发。（第三个参数默认为 false, 上面的例子中可忽略不写）\n\n为同一个元素添加同一个事件的对个事件处理程序函数：\n```js\nbtn.addEventListener('click', function() {\n  alert(\"Clicked-01\");\n});\n\nbtn.addEventListener('click', function() {\n  alert(\"Clicked-02\");\n});\n```\n\n这里给按钮的 click 事件添加了两个事件处理程序，这两个事件处理程序会按照添加的顺序触发。首先显示 \"Clicked-01\"，然后显示 \"Clicked-02\"。\n\n#### 移除事件处理程序\n使用 `addEventListener()` 添加的事件处理程序，可以通过 `removeEventListener()` 来移除，但是两个函数的参数必须相同。\n\n```js\nvar btn = document.getElementById('btn');\nfunction handler() {\n  alert(\"Cilcked\");\n}\n\nbtn.addEventListener('click', handler, false);\n\nbtn.removeEventListener('click', handler, true);  // 无效\n\nbtn.removeEventListener('click', handler, false);  // 有效\n```\n\n大多数情况下，都是讲事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各个浏览器。只在需要在事件到达目标之截获的时候将事件处理程序添加到捕获阶段\n","timeToRead":3}},{"node":{"id":"4599bc47-6dad-5d25-bc64-bef92732943b","frontmatter":{"title":"JavaScript 作用域与闭包","date":"2016/04/04","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016040413"},"excerpt":"作用域 在 JavaScript 中变量的作用域与其他语言不同，JavaScript 的作用域不是由   来界定，而是函数。所以循环实际上是在全局作用域中。 全局变量 & 局部变量 JavaScript 变量的作用域分为两种，全局和局部。 在 JavaScript 中声明全局变…","rawMarkdownBody":"\n## 作用域\n在 JavaScript 中变量的作用域与其他语言不同，JavaScript 的作用域不是由 `{}` 来界定，而是函数。所以循环实际上是在全局作用域中。\n\n``` js\nfor(var i = 0; i < 10; i++) {}\n\nconsole.log(i); // 10\n```\n\n### 全局变量 & 局部变量\nJavaScript 变量的作用域分为两种，全局和局部。\n\n在 JavaScript 中声明全局变量有两种方式，一种是在全局环境下使用 `var` 声明，另一种是在任何地方直接初始化变量，那么它将会是全局变量。\n\n<!--more-->\n``` js\nvar name = 'ahonn';   // 全局变量\n\nfunction f1() {\n  name = 'ahonn';   // 还是全局变量\n}\n```\n\n除了在任意地方直接初始化声明全局变量这一特殊之处外，JavaScript 全局变量还可以在函数内部直接读取。\n``` js\nvar name = 'ahonn';\n\nfunction f1() {\n  console.log(name);\n}\n\nf1(); // 'ahonn'\n```\n\n在函数中使用 `var` 定义的变量为局部变量。因为 JavaScript 的作用域是由函数界定，那么理所当然的函数外部是无法读取函数内部的局部变量。这一点其实其他的编程语言也是这样的。\n\n``` js\nfunction f1() {\n  var name = 'ahonn';\n}\n\nconsole.log(name) // Error\n```\n\n\n### 作用域链\n作用域链的原理与原型链很类似。在某个环境中为了读取变量时，会沿着作用域链来搜索这个变量，从作用域链的前端开始，向上级搜索。如果在当前局部环境中没有找到该变量，则继续沿作用域链向上搜索，直到最顶层。搜索到该变量时将停止搜索，如果到最后还是没有找到该变量，那么意味着这个变量是未定义的，即它的值为 `undefined`。\n\n```js\nvar a = 'a';\n\nfunction f1() {\n  var b = 'b';\n  console.log(a + b);\n}\n\nf1() // 'ab'\n```\n\n在这个例子中，在全局环境中定义了全局变量 a，然后在函数中定义了局部变量 b。函数通过 `console.log` 输出 a + b。\n\n首先在当前的局部环境中搜索变量 a 的值，没有找到。那么继续向上一级搜索，在全局环境中找到标识符为 a 的变量的值 'a'。接着在局部环境中搜索变量 b，得到局部变量 b 的值 'b'。最后输入变量 a 和 b 的值拼接后的字符串的值。\n\n## 闭包\n函数外部无法读取函数内部定义的局部变量，所以当我们需要读取局部变量时就需要使用到闭包。\n\n那么闭包是什么呢？我的理解是函数返回一个局部作用域来使得函数外部能够读取函数内部的变量。因为 JavaScript 中作用域的界定是由函数来完成的，所以实际上也就是在函数中再返回一个函数。闭包将函数内外给联系了起来。\n\n```js\nfunction f1() {\n  var name = 'ahonn';\n  return function () {\n    console.log(name);\n  }\n}\n\nvar f2 = f1();\nf2(); // 'ahonn'\n```\n\n一般情况下，当函数执行后，函数所在的局部环境将被销毁，也就是说函数在执行后函数中的变量是会被销毁的，在内存中就仅存在全局环境，即全局变量。\n\n但是使用闭包的情况又有所不同，在函数内部定义的匿名函数会包含函数（外部函数，即包含匿名函数的函数）中的变量。在外部函数执行完毕后，原本应该被销毁的局部变量不会被销毁，因为闭包的作用域链仍然在引用这些局部函数，内存的垃圾回收机制不会回收这部分变量所在的内存空间。直到匿名函数被销毁后，这些局部对象才会被销毁。\n\n### 内存泄漏\n由于闭包使得函数中的局部变量不会被垃圾回收机制回收，会依然存在于内存中，所以使用闭包的内存消耗很大，所以大量的使用闭包会造成性能问题。另外，在IE中可能会导致内存泄漏。解决方法是在退出函数前将不使用的局部变量全部删除。\n\n```js\nfunction f1() {\n  var e = document.getElementById('id');\n  var id = e.id;\n\n  e.onclick = function() {\n    alert(id);\n  }\n\n  e = null; // 删除不使用的局部变量值，只将需要的 id 保存为副本\n}\n```\n","timeToRead":1}},{"node":{"id":"08314926-2730-576d-bb51-04136d357325","frontmatter":{"title":"奇怪的 JavaScript 原型链","date":"2016/03/29","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016032912"},"excerpt":"在 JavaScript 中一切皆为对象（Object），但是却与 Java，C++ 等语言不同，没有“类”的概念，也没有所谓的“子类”和“父类”。JavaScript 中的对象是基于原型（prototype）来实现面向对象的，靠奇怪的原型链（prototype chain）来…","rawMarkdownBody":"\n在 JavaScript 中一切皆为对象（Object），但是却与 Java，C++ 等语言不同，没有“类”的概念，也没有所谓的“子类”和“父类”。JavaScript 中的对象是基于原型（prototype）来实现面向对象的，靠奇怪的原型链（prototype chain）来实现继承。\n\n## 对象与原型\n在 JavaScript 中创建对象使用 `new` 关键字，而后跟着的是构造函数。在 JavaScript 中没有类的概念，所以对象的构造函数就是单纯只是个函数（function）。\n\n<!--more-->\n创建自定义构造函数并使用构造函数创建对象：\n\n```js\nfunction Person() {\n  this.name = 'ahonn';\n}\n\nvar p1 = new Person();\n```\n\n单纯使用构造函数的方式来创建对象，有一个问题，那就是无法共享属性和方法，当两个对象都有一个同名的相同的方法时，方法会在每个实例上重新创建，这无疑是一种浪费。\n\n创建函数时，函数都会有一个原型（prototype）属性，该属性是一个指针，指向一个对象。而这个对象的用途就是包含那些共享的属性和方法。prototype 就是通过调用构造函数而创建的对象实例的原型对象。\n\n使用构造函数模式和原型模式来创建对象：\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayName = function () {\n  console.log(this.name);\n}\n\nvar p1 = new Person(\"ahonn\");\nvar p2 = new Person(\"person\");\n\np1.sayName(); // \"ahonn\"\np2.sayName(); // \"person\"\n```\n\n构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。这里有一点继承的味道，如果把 prototype 当作是父类的话，那么构造函数创建的对象就是原型对象的子类。\n\n## 继承与原型链\n每个构造函数都有一个原型对象（创建函数时会有一个原型属性），原型对象中包含一个指向构造函数的指针（constructor 指向构造函数）,而实例对象中包含一个指向原型对象的内部指针（实例对象中的 [[Prototype]], 它不能被显式的访问）。\n\n```js\nfunction Animal(name) {\n        this.name = name;\n}\nAnimal.prototype.age = 3;\nAnimal.prototype.sayName = function() {\n    return this.name;\n};\n\nvar animal = new Animal('Dog');\nconsole.log(animal.sayName());  // \"Dog\"\n```\n\n以上代码中，构造函数为 Animal ，Animal.prototype 是指向 Animal 的原型对象的指针，而原型对象中 Animal.prototype.constructor 属性指向构造函数，而 Animal 的实例中 [[Prototype]] 指向构造函数原型对象。\n\n> 在ECMA-262中定义此指针为[[Prototype]]，并不能被显式的访问到，而在Firefox,Safari和Chrome中每个对象上有一个__proto__属性。\n\n那么如果这里面的原型对象是另一个实例对象的话，就可以使得实例与实例之间产生了关联，并且由于原型对象是另一个实例对象的关系，此时这个作为原型对象的实例对象的属性和方法变成了原型对象对应的构造函数创建的实例的“父类”。\n\n这样层层递进，构成实例和原型间的链条，就让实例之间产生了关联，那么就实现了继承。这个就是原型链的基本概念。\n\n实现原型继承的简单示例：\n\n```js\nfunction Animal() {\n  this.name = \"Animal\";\n}\n\nAnimal.prototype.eat = function () {\n  console.log(\"Animal can eating\");\n}\n\nfunction Dog() {\n  this.name = \"Dog\";\n}\n\n// 通过原型继承，继承 Animal 的属性和方法，创建了 Dog 与 Animal 之间的原型链\nDog.prototype = new Animal();\n\n// 修复 Dog 对象的原型对象中的 constructor\nDog.prototype.constructor = Dog;\n\nvar dog = new Dog();\n\n// Dog 中重写了原型中的 name 属性，即所继承的 Animal 中的 name 属性\nconsole.log(dog.name); // \"Dog\";\n\n// 同时继承了原型中的方法\ndog.eat(); // \"Animal can eating\"\n```\n","timeToRead":1}},{"node":{"id":"1cb37010-863b-55d7-b9d1-2b42dcbe4143","frontmatter":{"title":"apply, call 与 bind 的区别","date":"2016/03/20","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/2016032011"},"excerpt":"最近在看 《JavaScript 高级程序设计》，也就是所谓的高程3。正好看到   部分，看到了几个熟悉的字眼， ，  和  。好像是有些面试题里面有，遂搞清楚了记录下。 apply() 与 call() 每个函数都包含两个非继承的方法：  和  。两个方法的用途都是在特定的作…","rawMarkdownBody":"\n最近在看 《JavaScript 高级程序设计》，也就是所谓的高程3。正好看到 `Function` 部分，看到了几个熟悉的字眼，`apply()`，`call()` 和 `bind()`。好像是有些面试题里面有，遂搞清楚了记录下。\n\n## apply() 与 call()\n\n每个函数都包含两个非继承的方法：`apply()` 和 `call()`。两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 `this` 对象的值。这是书中的说法，大概意思就是 `apply()` 和 `call()` 这两个方法是用来改变函数中 `this` 的指向的。而 `apply()` 与 `call()` 的区别就在与接收参数的方式。\n\n`apply()` 方法接收两个参数，一个是在其中运行函数的作用域，函数中的 `this` 的值，另一个是参数数组。\n而 `call()` 方法的第一个参数跟 `apply()` 相同，不同的是除了第一个参数，后面的其他参数将会直接传递给函数。\n\n<!--more-->\n```\nfunction sum(num1, num2) {\n  return num1 + num2;\n}\n\n// 使用 apply()\nfunction applySum(num1, num2) {\n  return sum.apply(this, arguments);\n}\n\n// 使用 call()\nfunction callSum(num1, num2) {\n  return sum.call(this, num1, num2);\n}\n\nalert(applySum(1, 2)); // 3\nalert(callSum(1, 2)); // 3\n```\n\n这里使用 `apply()` 与 `call()` 的效果都是一样的，不同的只是除了 `this` 的指向之外的参数的传递形式不同。在不给函数传递参数的时候则完全一样，当不知道需要传递的函数参数的个数时，使用 `apply()` 更好。\n\n实际上 `apply()` 与 `call()` 的用法并不只是这些。他们可以扩充函数赖以运行的作用域，即可以改变函数运行时的上下文。\n\n```\nname = \"unknown\";\nvar person = {\n  name = \"ahonn\";\n}\n\nfunction sayName() {\n  console.log(this.name);\n}\n\nsayName() // unknown\n// 函数中的 this 为全局环境\nsayName.apply(this); // unknown\n// 函数中的 this 指向了 person\nsayName.apply(person) // ahonn\n```\n\n上面的例子中的 `apply()` 换成 `call()` 的话效果相同，因为我这样只给 `apply()` 传了第一个参数。\n\n## bind()\n`bind()` 方法与 `apply()` 和 `call()` 相似，同样是可以改变函数内 this 的指向。但与 `apply()`, `call()` 不同的是，`bind()` 方法会创建一个新函数，称为绑定函数，当调用绑定函数时，函数会以创建时的第一个参数 this 作为函数运行的作用域。\n\n```\nname = \"unknown\";\nvar person = {\n  name = \"ahonn\";\n}\n\nfunction sayName() {\n  console.log(this.name);\n}\n\nvar sayAhonnName = sayName.bind(person);\n\n// 函数中的 this 指向 person\nsayAhonnName() // ahonn\n```\n\n也就是说，`bind()` 方法可以绑定一个上下文到函数中，产生一个新的绑定函数。这样就可以在需要的时候去运行有指定 this 对象的函数。\n\n使用变量保存 this 的做法：\n```\nvar foo = {\n  bar: 1,\n  eventBind: function() {\n    var _this = this;\n    $('.someClass').on('click', function(event) {\n      console.log(_this.bar);\n    });\n  }\n}\n```\n\n因为在 JavaScript 中函数也是对象，使用如果不使用 `_this` 来保存上下文环境的话，在绑定的事件函数中将找不到 `bar` 这个值，因为上下文环境发生了改变。更优雅的做法就是使用 `bind()` 来完成。\n\n```\nvar foo = {\n    bar : 1,\n    eventBind: function(){\n        $('.someClass').on('click',function(event) {\n            console.log(this.bar);\n        }.bind(this));\n    }\n}\n```\n\n这样就把 `$('.someClass').on('click',function(event) {}` 外的上下文环境给绑定到了函数内了。\n","timeToRead":2}},{"node":{"id":"e33b2277-a2ec-5aaa-9b1a-397487627a51","frontmatter":{"title":"Jade 模板引擎","date":"2016/02/29","tags":["Jade","前端"]},"fields":{"slug":"/posts/2016022910"},"excerpt":"最近在改一个 Hexo 的主题  apollo 。然后看到这个主题用的是叫做 Jade 的模版引擎写的。之前了解过几个模版引擎 ejs，swig 什么的，但是这些都是在原有的 HTML 中插标签，看起来有点乱。看到 Jade 后就深深的被它那如同 Python 的缩进语法深深吸…","rawMarkdownBody":"\n最近在改一个 Hexo 的主题 [apollo](https://github.com/pinggod/hexo-theme-apollo)。然后看到这个主题用的是叫做 Jade 的模版引擎写的。之前了解过几个模版引擎 ejs，swig 什么的，但是这些都是在原有的 HTML 中插标签，看起来有点乱。看到 Jade 后就深深的被它那如同 Python 的缩进语法深深吸引了，遂上网学习一发。\n\nJade 是 JavaScript 实现的，供 Node 使用，原生支持 Express。但也有 PHP，Python 等其他语言的实现。（要是 HTML 模版用 Jade，CSS 用 Styl，后端用 Python，那岂不是很好玩~全是缩进缩进缩进=。=）\n\n\n### DOCTYPE\n\n添加文档类型可以通过 `!!!`  或者 `doctype ` 来添加。\n\n<!--more-->\n### 标签、属性\n\n Jade 写起来就跟在 Sublime Text 中用 Emmet 写 HTML 一样。标签直接写，Class 用 `.`，ID 用 `#`。不同的是，层级关系 Jade 使用缩进表示，类似于 Python，而 Emmet 插件的写法是只有一行的。结果写出来就是这个样子滴：\n\n``` jade\ndoctype html\nhtml\n\thead.class\n    \ttitle\n    body#id\n```\n\n渲染出来的结果:\n\n``` html\n<!DOCTYPE html>\n<html>\n  <head class=\"class\">\n    <title></title>\n  </head>\n  <body id=\"id\">\n  </body>\n</html>\n```\n\n看起来超级简洁，而且都不需要去写闭合标签。不过比较需要注意缩进，坏处就是如果复制代码过来的话可能需要重新人脑格式化一下。\n\n\n\n那么问题来了，其他属性怎么办？不是 Class 和 id 的话，就可以在 标签后面加个括号，写在括号里面。当属性值 `undefined` 或者 `null` 时，该属性将不会编译。\n\n``` jade\na(href=\"http://www.ahonn.me\", class=null)\n```\n\n渲染为：\n\n``` html\n<a href=\"http://www.ahonn.me></a>\n```\n\n这样就解决了其他属性的问题了~\n\n\n\n### 文本\n\n那么标签里的文本怎么写呢，so easy~ 只要跟在标签的后面就行了。Like this:\n\n``` jade\na(href=\"http://www.ahonn.me\") Ahonn\n```\n\n渲染为：\n\n``` html\n<a href=\"http://www.ahonn.me>Ahonn</a>\n```\n\n\n\n大段文本的话可以使用`|` 或者`.`：\n\n使用 `|`：\n\n``` jade\np\n  | one\n  | two\n  | there\n```\n\n使用`.`:\n\n``` jade\np.\n  one\n  two\n  there\n```\n\n\n\n上面两种写法渲染后是不一样的，使用 `|` 的写法渲染后不会换行，而使用 `.` 会根据格式原样输出。\n\n``` html\n<!-- 使用 | -->\n<p>one two there</p>\n<!-- 使用 . -->\n<p>one\ntwo\nthere\n</p>\n```\n\n在使用 `script`、`style`、`textarea` 等只包含文本标签时，可以不加前缀 `|`，\n\n当需要在模版中写 JavaScript 时，推荐使用 `.`。\n\n\n\n既然是 HTML 模版，那么一定是可以结合数据的。这时候，我们可以用 `#{}` 将变量包起来。这样的话 `#{}`  中的值将会被转义成对应的数据。\n\n例如：\n\n``` jade\n- var name = \"ahonn\"\np.\n My name is #{name}\n```\n\n渲染为：\n\n```html\n<p>My name is ahonn</p>\n```\n\n\n\n### 注释\n\njade 支持 HTML 的注释，即在 html 代码中能看到的注释，还有一种是 Jade 的注释，不会被渲染。\n\n```jade\n// HTML 注释\np foo\n//- Jade 注释，这个注释只有在 .jade 文件中显示\np bar\n```\n\n渲染为：\n\n``` html\n<!-- HTML 注释 -->\n<p>foo</p>\n<p>bar</p>\n```\n\n\n\n### 代码\n\n在 Jade 中可以定义变量，写条件语句或者循环什么的，这时候就需要使用到 `-` 前缀，这不会被输出。 `-` 支持 JavaScript 的语法。\n\n``` jade\n- var foo = 'bar';\n- if (foo === 'bar')\n- for (var key in obj)\n  p= obj[key]\n```\n\n上面写的条件和循环语句是 JavaScript 中的写法，同时 Jade 也有自己的条件和循环语句。\n\n**循环**：\n\n``` jade\n- var items = [\"one\", \"two\", \"there\"]\neach item, i in items\n  li #{item}: #{i}\n```\n\n渲染为：\n\n``` html\n<li>one: 0</li>\n<li>two: 1</li>\n<li>three: 2</li>\n```\n\n**条件**：\n\n条件语句类似 Python，不需要加 `()`\n\n``` jade\nfor user in users\n  if user.role == 'admin'\n    p #{user.name} is an admin\n  else\n    p= user.name\n```\n\n\n\nJade 支持转义和非转义输出，使用 `=` 时将会转义，而 `!=` 将会原样输出。\n\n例如：\n\n``` jade\n- var  ahonn = 'nnoha'\np= ahonn\np!= ahonn\n```\n\n渲染为：\n\n``` html\n<p>nnoha</p>\n<p>ahonn</p>\n```\n\n\n\n### 继承、包含\n\n#### 继承\n\nJade 支持通过 `block` 和 `extends` 关键字老实现模版继承，`block` 部分将在子模块实现。\n\n举个栗子🌰：\n\nlayout.jade\n\n``` jade\n!!!\nhtml\n  head\n  \tblock title\n  body\n  \tblock content\n```\n\nindex.jade\n\n``` jade\nextends layout\n\nblock title\n  title= ahonn\n\nblock content\n  p.\n    My name is ahonn.\n    This is index.jade\n```\n\n\n\nindex.jade 继承 layout.jade，layout 中的 block 部分将在子模版 index 中实现。\n\nindex.jade 渲染为：\n\n``` html\n<DOCTYPE html>\n<html>\n  <head>\n    <title>ahonn</title>\n  </head>\n  <body>\n  \t<p>My name is ahonn.\n    This is index.jade\n    </p>\n  </body>\n</html>\n```\n\n\n\n#### 包含\n\nJade 可以使用 `include` 静态包含其他文件\n\nhead.jade\n\n``` jade\nhead\n  title!= ahonn\n```\n\nbody.jade\n\n``` jade\nbody\n  p.\n    My name is ahonn.\n    This is index.jade\n```\n\nindex.jade\n\n````jade\nhtml\n  include head\n  include body\n````\n\n\n\n渲染结果将于上面继承的相同。\n\n\n\n### Mixins\n\nMixins 相当于 JavaScript 中的函数，实际上 Mixins 在编译过程中就是被转换为 JavaScript 函数的。\n\n不带参数的 🌰：\n\n``` jade\nmixin list\n  ul\n\tli foo\n    li bar\n\nh2!= Ahonn\n+list()\n```\n\n渲染为：\n\n``` html\n<h2>Ahonn</h2>\n<ul>\n  <li>foo</li>\n  <li>bar</li>\n</ul>\n```\n\n\n\n带参数的 🌰：\n\n``` jade\nmixin list(items)\n  ul\n    - each item in items\n      li= item\n\n- var items = [\"foo\", \"bar\"]\nh2!= Ahonn\n+list(items)\n```\n\n渲染结果与上面无参数的 Mixins 相同。\n\n\n\n### 总结\n\n使用 Jade 写模版非常的简洁，各种 `include` 和 `extends` 使用起来也非常方便，可以模块化的去写各个组件。优点显而易见，对于我这种写 Python 的来说简直是大爱。不过可能这种写法相对于其他模版引擎来说差别较大，跟 HTML 代码的差别也挺大，所以相对来说也是比较少人去用了。而且用这个写的话，写的人来维护的倒是挺方便简洁，但是如果是其他人来维护的话还是比较难上手的，有点增加维护成本的感觉。不过我个人倒是挺喜欢的。\n","timeToRead":4}},{"node":{"id":"abe65c21-4e59-5893-91c2-85509e4e2e7b","frontmatter":{"title":"Python 多线程初步了解","date":"2016/02/20","tags":["Python"]},"fields":{"slug":"/posts/201602209"},"excerpt":"这两天在写  Nada  的下载功能，遇到一个问题，在下载歌曲的时候整个界面都会卡住，必须等待下载完成才能够恢复，因为写的时候是直接顺序执行的，没有多线程。之前在写播放功能的时候是参考了别人的代码，自己其实对多线程部分不是很了解。然后趁着晚上了解一下 Python 的 thre…","rawMarkdownBody":"\n这两天在写 [Nada](https://www.github.com/ahonn/Nada) 的下载功能，遇到一个问题，在下载歌曲的时候整个界面都会卡住，必须等待下载完成才能够恢复，因为写的时候是直接顺序执行的，没有多线程。之前在写播放功能的时候是参考了别人的代码，自己其实对多线程部分不是很了解。然后趁着晚上了解一下 Python 的 thread 和 treading 模块。\n\n## Python 多线程支持\nPyhton 标准库提供了 thread 和 threading 模块来支持多线程，这意味着不需要重新下载这两个模块，只需要在代码中 import 这两个模块就可以了。\n\n## thread 模块\nthread 模块是以低级、原始的方式来处理和控制线程，提供了一个简单的锁（相对于 threading 模块的锁的感觉来说的确是比较简单）。相对于 threading 模块来说，thread 模块更加灵活。\n\n<!--more-->\n- `thread.start_new_thread(function, args [, kwargs])`\n  创建一个新的线程，返回该线程的标识符。线程执行后将制动退出，即函数执行完毕。当遇到未处理的异常时也将退出，但不影响其他线程。\n  * `function`：线程执行的函数。\n  * `args`：线程执行函数的参数。\n  * `kwargs`：为函数提供命名参数字典。\n\n- `thread.exit()`\n  结束当前进程，触发 SystemExit 异常。\n\n- `thread.get_ident()`\n  返回当前线程的标识符，标识符为一个非零整数。\n\n- `thread.interrupt_main()`\n  触发主线程的 KeyboardInterrupt 异常，子线程使用此方法来终端主线程。\n\n- `thread.allocate_lock()`\n  创建 thread.LockType 锁类型，即为线程锁\n\n### thread.LockType\n\n- `Lock.acquire([ waitflag ])`\n  获取锁，返回一个布尔值，成功返回 True，否则返回 False。\n\n  `waitflag`：默认值为非零整数，表示如果锁已经被其他线程占用，那么当前线程等待，直到其他线程释放锁，即为同步阻塞。如果将参数设置为 0，即表示当前线程会尝试获取锁，不管锁是否被占用，线程都不会等待。\n\n- `Lock.release()`\n  释放所占用的锁。\n\n- `Lock.locked()`\n  判断锁是否被占用。\n\n## threading 模块\nthreading 模块是对 thread 模块的二次封装，提供更方便的 API 使用。大多数多线程使用 threading 模块编写。提供更复杂的锁（Lock & RLock），条件，事件等。\n\n- `threading.Thread(group=None, target=None,name=None, args=(), kwargs={})`\n  返回一个Thread对象，每个Thread对象代表着一个线程，可以通过start()方法，开始运行。\n\n  * `group`：应该为 None ，该参数是留给未来的扩展时使用的\n  * `target`：可调用对象（函数），在线程启动后执行\n  * `name`：线程的名字，默认值为“Thread-N”，N 是一个十进制整数\n  * `args`：target 调用对象的参数列表\n  * `kwargs`：target 调用对象的关键字参数\n\n- `threading.activeCount()`\n  返回当前存活线程数\n\n- `threading.currentThread()`\n  返回当前 Thread 对象\n\n- `threading.enumerate()`\n  返回当前存活的 Thread 对象列表\n\n- `threading.Lock()`\n  返回一个原始锁对象\n\n### threading.Thread\n有两种方式来创建 threading.Thread 对象。一种方式是继承 Thread 类，重写父类的 run 方法，另一种方式是通过 threading.Thread() 函数创建。\n\n- `Thread.start()`\n  启动线程\n\n- `Thread.join([timeout])`\n  阻塞当前环境进程，直到调用此方法的线程终止，或者达到指定的 timeout\n\n- `Thread.getName()` & `Thread.setName()`\n  获取线程名称 & 设置线程名称\n\n- `Thread.isAlive()`\n  返回线程是否存活。返回 True 在线程开始运行直到终止。\n\n### threading.Lock\n- `Lock.acquire([blocking])`\n  获取锁。`blocking` 默认为 true，阻塞直到锁被释放。当 `blocking` 为 False 时，则不阻塞。\n\n- `Lock.release()`\n  释放锁，没有返回值。当没有锁时，将会抛出 ThreadError 异常。\n","timeToRead":2}},{"node":{"id":"b5694877-276c-5b1a-9b67-974fe0bbf4c3","frontmatter":{"title":"Python curses 模块","date":"2016/01/23","tags":["Python"]},"fields":{"slug":"/posts/201601238"},"excerpt":"Python 中的 curses 模块封装了 C 语言的 curses。curses 是一个能够提供基于文本终端窗口功能的动态库。它可以创建和管理一个窗口，使用8中不同的颜色，提供鼠标以及键盘支持。与 Tkinter 不同的是 curses 是基于终端的。 curses 支持 …","rawMarkdownBody":"\nPython 中的 curses 模块封装了 C 语言的 curses。curses 是一个能够提供基于文本终端窗口功能的动态库。它可以创建和管理一个窗口，使用8中不同的颜色，提供鼠标以及键盘支持。与 Tkinter 不同的是 curses 是基于终端的。\n\n**curses 支持 Unix/Linux 系统，目前不支持 Windows**\n<!--more-->\n\n## 基本语法\n- `initscr()`\n\t初始化 curses, 在任何代码执行钱都需要先初始化 curses。\n- `noecho()`\n\t关闭屏幕回显，即读取字符仅在适当的环境下输出。相对应的是 `echo()`。\n- `cbreak()`\n\t程序立即反应，即不需要按回车。相对应的是 `nocbreak()`。\n- `keypad(bool)`\n\t键盘模式，即读取键盘输出。`keypad(1)` 为开启，`keypad(0)` 为关闭。\n- `endwin()`\n\t恢复默认设置，即回到终端之前的状态。\n- `newwin(height, width, begin_y, begin_x)`\n\t在原有程序中创建新窗口，类似与分屏。\n- `addscr(y, x, str, attr)`\n\t显示文本，若没有坐标，字符将显示在上一次操作完的位置；若没有属性，字符将使用默认的属性显示。\n\n\t**属性：**可使用 `color_pair(int)` 方法获取一对颜色。使用 `init_pair(n, f, b)` 修改颜色对 n，使用 f 为前景色，使用 b 为背景色。\n\n\tcurses 内置了8种基本颜色：`COLOR_RED`, `COLOR_BLACK`, `COLOR_GREEN`, `COLOR_YELLOW`, `COLOR_BULE`, `COLOR_MAGENTA`, `COLOR_CYAN`, `COLOR_WHITE`。使用颜色前需要调用 `start_color()`。\n- getch()\n\t获取输入一个字符串，返回一个 0~255 之间的整数，表示字符的 ASCII 值。\n- refresh()\n\t刷新窗口，变更窗口后需要调用\n\n## 基本使用\n``` python\nimport curses\n\n# 初始化 curses\nscreen = curses.initscr()\n# 开启键盘模式\nscreen.keypad(1)\n# 关闭屏幕回显\ncurses.noecho()\n\n# 开启颜色设置，并设置颜色对\ncurses.start_color()\ncurses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_RED)\ncurses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_WHITE)\n\n# 显示文本\nscreen.addstr(12, 25, \"Hello, Ahonn!\")\nwhile True:\n\t# 读取键盘输入\n\tkey = screen.getch()\n\n\t# 当输入 c 时，显示 you input 'c', 使用颜色对 1\n\tif key == ord('c'):\n\t\tscreen.addstr(12, 25, \"you input 'c' \", curses.color_pair(1))\n\t# 当输入 b 时，显示 you input 'b'，使用颜色对 2\n\telif key == ord('b'):\n\t\tscreen.addstr(12, 25, \"you input 'b' \", curses.color_pair(2))\n\t# 当输入 q 时退出循环\n\telif key == ord('q'):\n\t\tbreak\n# 刷新窗口\nscreen.refresh()\n# 退出到终端之前的状态\ncurses.endwin()\n```\n","timeToRead":1}},{"node":{"id":"1f6cb47e-6f2b-5e2d-936d-2503d8d5c067","frontmatter":{"title":"2015 总结","date":"2015/12/31","tags":["年终总结"]},"fields":{"slug":"/posts/201512317"},"excerpt":"记录 2015，计划 2016 关于生活 对2015 年的春节并没什么印象，现在也想不起来那时候在做什么了。大概是在游戏中度日吧，回想那段日子，现在还真是觉得那时候在浪费时间呢。 接着呢就是大一的第二个学期的到来。数据结构，对这门课还挺感兴趣呢，学起来也觉得还 ok。大概在 3…","rawMarkdownBody":"> 记录 2015，计划 2016\n\n## 关于生活\n\n对2015 年的春节并没什么印象，现在也想不起来那时候在做什么了。大概是在游戏中度日吧，回想那段日子，现在还真是觉得那时候在浪费时间呢。\n\n接着呢就是大一的第二个学期的到来。数据结构，对这门课还挺感兴趣呢，学起来也觉得还 ok。大概在 3 月，被老师推荐去了学校刚刚开始搞得 ACM 集训队。开始重新看起了 C，但是依旧还是会沉浸在游戏中。\n\n就这样在做题，训练与游戏中到了五一。回家之后不知道是那根筋不对，开始对 Linux 感兴趣了，把电脑上的游戏删了，把系统换成了 Ubuntu。假期期间换了无数 Linux 发行版，也开始慢慢了解开源。于是，我开始玩起了 Ubuntu。假期结束接着的是 ACM 的各种比赛，去了广州的各大高校，参加了在中大举办的广东省程序设计比赛，打了打酱油。看到了很多虽然同是大一的大牛，差距是那么的大。\n\n就这样我又默默的水过了一个学期，唯一值得纪念的就是去了中大打了酱油吧。\n\n大二。刚开始对课程里的人机交互还是充满期待的，但是后面我发现我错了，这只是一门网页设计与推广某个所谓创业平台的课。所以说，像这样的大学，虽然也不乏良师，但大部分还是靠的自学。\n\n<!--more-->\n被所谓的创新创业潮影响，学校里也开始浮躁起来了，各种创业。在我的眼里，那些所谓的创业不过是有一个想法，然后把想法变成嘴皮子与 PPT，再去参加一些什么创业比赛拿拿奖。相对这些我还是更喜欢那些线下交流会，或者之前看到的 SF 的编程马拉松这种。或许我本身的性格也就比较不适合这些吧。\n\n很快，学校又迎来了一大批像一年的我一样迷茫的大一新生。接着便是纳新宣传，面试，培训，竞选。在这期间跟着一群很不错的小伙伴一起做事，虽然有时会出现一些矛盾，但是那一段时间过得也是蛮开心的。面试师弟师妹的时候，回想起一年前的我，虽然我已经忘记了当时面试的情景了，但是依然感触很深。第一次培训师弟师妹的时候非常紧张，那个时候是讲 HTML ，怕我自己讲的不好一直会问他们听得懂吗，ok吗。讲完的时候会有好险已经讲完了的感觉，不过后来慢慢变好了，到最后都可以在讲台上跟下面的人吹牛逼了。这对我来说，应该是一个很大的改变。\n\n换届大会之后，我成了负责人。然而有些小伙伴却因为某些原因，离开了。换届之后留下了一个烂摊子收拾，忙着申请培训的课室，忙着搞 12 月的周年庆晚会。开始有点慌了手脚，但是有时候不逼逼自己真的不知道自己是可以做到的。还好，晚会圆满成功。当我最后在台上讲话的时候，我的眼睛里全是射灯的光，什么都看不到，但是心情却是说不出的激动。这应该是人生中第一次由我负责的晚会表演。师弟师妹们很给力，也很努力，我很开心。\n\n就这样我大二的一半就要结束了，大学也将近一半。\n\n以上，2015。\n\n2016\n我期望我能够收获更多\n对于即将到来的变化，拥抱变化\n勿忘初心，记住自己想要的是什么\n好好做人生的选择题，即使做错了也欣然接受\n\n## 关于学习\n**2015 List**\n- 重新捡起曾经学过的 C ，扩展的了解了C ++，为了在 ACM 的比赛中不会太被动\n- 装了 Linux 单系统，学会了常用的命令行操作\n- 暑假的时候学了 Python ，学会了些爬虫\n- 小学期，把 PHP 又好好的复习了一下，学了 Codeigniter\n- 重新学了一次 JavaScript 及 jQuery，了解了一点 AngularJS\n- 看着网上的一个由 Java 写的验证码识别写了 PHP 的，虽然没有很好的完成\n- 微信群里听说了 Face++，然后爬了下教务网的照片，做了一个简陋的人脸识别，识别率堪忧\n- 写了一个知乎网页解析，放在了 Github 上\n- 在 2015 的倒数第二天，在 Github 上参加了一个编程马拉松 [coding_marathon](https://github.com/geekan/coding_marathon/issues/12)\n\n**2016 To Do List**\n- 完成 Github 上的那个编程马拉松，并且有质量的 commit（没有完成，但在过程中学到很多东西）\n- ~~读完 《JavaScript 高级程序设计》~~（马马虎虎的看了一遍）\n- ~~完成百度前端技术学院的春季班~~（算是完成了一半吧）\n- ~~学习 React, React Native 等~~（基本上熟悉 React，React Native 部分没怎么看）\n- more...\n\n**--------------------End--------------------**\n","timeToRead":1}},{"node":{"id":"65d333fa-cc57-5a73-9073-a2b0966e6639","frontmatter":{"title":"在 PHP 中如何预防 SQL 注入","date":"2015/12/21","tags":["PHP","SQL"]},"fields":{"slug":"/posts/201512216"},"excerpt":"翻译自 Stack Overflow:  How can I prevent SQL-injection in PHP?  中的高票答案 Question 如果用户输入的数据没有经过修正，那么应用将会很容易受到 SQL 注入攻击，像下面的这个例子一样： 上面的例子，会因为用户输…","rawMarkdownBody":"> 翻译自 Stack Overflow: [How can I prevent SQL-injection in PHP?](http://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php) 中的高票答案\n\n## Question\n如果用户输入的数据没有经过修正，那么应用将会很容易受到 SQL 注入攻击，像下面的这个例子一样：\n``` php\n$unsafe_variable = $_POST['user_input'];\n\nmysql_query(\"INSERT INTO `table` (`column`) VALUES ('$unsafe_variable')\");\n```\n<!--more-->\n\n上面的例子，会因为用户输入像 `value'); DROP TABLE table;--` 这样的数据，使得 SQL 语句变成：\n```\nINSERT INTO `table` (`column`) VALUES('value'); DROP TABLE table;--')\n```\n\n应该如何去预防这样的事情发生？\n\n## Answer\n**使用预处理语句以及参数化查询来预防 SQL 注入**\n\n在发送到数据库前，对每一个参数进行解析。这种处理方式是不可能受到攻击者恶意 SQL 注入的。\n\n有两种基本操作可以选择，来达到这个目的：\n\n- 使用 PDO(PHP Data Objects)：支持所有的主流数据库\n``` php\n$stmt = $pdo->prepare('SELECT * FROM employees WHERE name = :name');\n\n$stmt->execute(array('name' => $name));\n\nforeach ($stmt as $row) {\n    // do something with $row\n}\n```\n\n- 使用 MySQLi：支持 MySQL 数据库\n``` php\n$stmt = $dbConnection->prepare('SELECT * FROM employees WHERE name = ?');\n$stmt->bind_param('s', $name);\n\n$stmt->execute();\n\n$result = $stmt->get_result();\nwhile ($row = $result->fetch_assoc()) {\n    // do something with $row\n}\n```\n如果连接到 MySQL 之外的数据库，有其他的驱动可以选择，例如 `PostgreSQL` 可以使用 `pg_prepare()` 和 `pg_execute()`。PDO 是一个比较普遍的选择，因为它可以兼容更多的数据库。\n\n**正确的建立连接**\n注意，当使用PDO访问MySQL数据库时，默认不使用预处理语句。要解决这个问题，需要禁用预处理语句的模拟 `ATTR_EMULATE_PREPARES` 。\n\n> **PDO::ATTR_EMULATE_PREPARES:**\n> 启用或禁用预处理语句的模拟。 有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为 TRUE ），或试着使用本地预处理语句（如果为 FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要 bool 类型。\n\n一个正确建立 PDO 连接的例子：\n``` php\n$dbConnection = new PDO('mysql:dbname=dbtest;host=127.0.0.1;charset=utf8', 'user', 'pass');\n\n$dbConnection->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n$dbConnection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n```\n\n在上面的例子中错误模式并不是必要的，但建议添加它。这样脚本就不会因为一个致命错误而报错停止，让开发人员有机会去捕捉抛出的异常并进行处理。\n\n第一个 `setAttribute()` 是告诉 PDO 禁用预处理语句的模拟，使用真正准备好的预处理语句。这确保语句与值不会在 PHP 解析之前就发送到 MySQL。尽管你可以在选项中设置字符集的构造函数，但是要注意，PHP版本 < 5.3.6，默认无视 DSN 的字符参数。\n\n**额外说明**\nSQL 语句会通过预处理解析以及数据库的编译。通过指定参数(例如 ? 或者 :name 之类的参数)，告诉数据库引擎那些是你想要过滤的。当执行语句时，预处理过的语句将会结合参数去执行。\n\n最重要的是，参数值结合编译的语句之后，它不是一个 SQL 字符串。SQL 注入是通过恶意字符串创建 SQL 发送到数据库的一种攻击。所以分开发送实际的 SQL 参数，可以降低被注入的风险，避免造成一些不希望看到的结果。任何发送的参数，将会在使用预处理之后被当做是字符串。\n\n在上面的例子中，如果变量 `$name` 的值是 `'Sarah'; DELETE FROM employees`，那么结果将会是查找字符串 `\"'Sarah'; DELETE FROM employees\"`，而且也将不会得到一个空表。（即是后面的 `DELETE FROM employees` 将被当成字符串，而不是当做 SQL 语句去执行）\n\n> 使用预处理语句的另一个好处是，如果你在同一个会话中多次执行相同的语句，语句只会被解析和编译一次，在速度上也有一点提升。\n\n下面是一个使用 PDO 来插入数据的例子：\n``` php\n$preparedStatement = $db->prepare('INSERT INTO table (column) VALUES (:column)');\n\n$preparedStatement->execute(array('column' => $unsafeValue));\n```\n\n**动态查询**\n动态查询依旧可以使用预处理语句去进行，对用某些不能参数化的数据，可以使用白名单来限制可能的值。例如：\n``` php\n// Value whitelist\n  // $dir can only be 'DESC' or 'ASC'\n$dir = !empty($direction) ? 'DESC' : 'ASC';\n```\n\n总之，对于用户输入的所有数据都应该在发送到数据库查询之前进行预处理，以此来过滤那些不安全的参数。使得不会因为被 SQL 注入攻击而产生意想不到的结果。\n\n","timeToRead":2}},{"node":{"id":"ceebbba4-59d0-5a25-9f9d-7a30e05dc0ac","frontmatter":{"title":"PHP cURL 库的简单使用","date":"2015/12/19","tags":["PHP"]},"fields":{"slug":"/posts/201512195"},"excerpt":"之前写 PHP 的爬虫的时候就有用到 cURl 扩展，然后前几天在写   的时候也用到了这个，也觉得这个也是用得比较多的一个东西，所以就上网又学习了一下，就顺手把它写下来了。 cURL 是一个功能强大的库，支持很多不同的协议、选项，能提供 URL 请求相关的各种细节信息。常用于…","rawMarkdownBody":"\n> 之前写 PHP 的爬虫的时候就有用到 cURl 扩展，然后前几天在写 `zhihu-php` 的时候也用到了这个，也觉得这个也是用得比较多的一个东西，所以就上网又学习了一下，就顺手把它写下来了。\n\ncURL 是一个功能强大的库，支持很多不同的协议、选项，能提供 URL 请求相关的各种细节信息。常用于网页、数据采集。\n\n## 安装\n可以通过 `phpinfo()` 来输出 PHP 的配置信息，搜索查看是否开启了 cURL 库。\n\n**windows**\n- 将 PHP 安装文件夹下的 `php_curl.dll`，`libeay32.dll`，`ssleay.dll` 复制到 `system32` 文件夹下。\n- 将 PHP.ini 中的 `extension=php_curl.dll` 前的 `;` 分号去掉。\n- 重启服务器。\n<!--more-->\n\n**linux**\nUbuntu 上通过 `apt-get` 安装的 PHP 默认已经启用。若无，具体安装过程Google。\n\n## 基本使用\n通过 `curl_init()` 初始化一个 cURL 对象，然后通过 `curl_setopt()` 设置传输的选项，使用 `curl_exec()` 执行该 cURL 会话，最后通过 `curl_close()` 关闭这个会话\n\n**简单的抓取网页**\n``` php\n<?php\n$url = 'http://www.ahonn.me';\n// 初始化一个 cURL 会话\n$ch  = curl_init($url);\n// 设置传输选项，这里设置的是返回的数据不直接输出\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n// 执行该会话，并保存到 $content\n$content = curl_exec($ch);\n// 关闭该会话\ncurl_close($ch);\n// 输出抓取的网页\necho $content;\n```\n\n**使用post方式**\n通过 `get` 方式获取时，可以直接在 `$url` 中直接写入。而当需要使用 `post` 方式获取数据时，需要通过以下设置来开启 post 并设置 post 的数据。\n\n``` php\n// 开启 post\ncurl_setopt($ch, CURLOPT_POST, 1);\n// 设置 post 的数据\ncurl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n```\n\n其中的 `$data` 即是需要 post 的数据。\n\n**设置header**\n有些网页需要在请求中包含头信息，否则将抓取不到你需要的信息，那么可以通过下面的代码来设置：\n``` php\n// 头信息数组\n$header = array(\n\t\t\"Host: www.ahonn.me\",\n\t\t\"Accept: text/html, application/xhtml+xml, image/jxr, */*\",\n\t\t\"User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36\"\n);\n// 设置header\ncurl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n```\n\n设置头信息可以通过数组的形式，然后通过设置 `CURLOPT_HTTPHEADER` 来加入头信息。也可以单个去设置，例如\n- `CURLOPT_USERAGENT`：设置 User-Agent\n- `CURLOPT_REFERER`：设置 Referer\n\n等等\n\n**设置cookie**\n有些网页需要登录后才可以抓取到，这时候就需要使用 cookie 来模拟登录。设置 cookie 可以在上面的 $header 数组中与头信息设置相同的方法来将 cookie 加入。也可以使用下面的 `curl_setpot` 选项来设置：\n``` php\n\t// 设置 cookie，$cookie 是一个字符串\n\tcurl_setopt($ch, CURLOPT_COOKIE, $cookie);\n```\n\n也可以通过文件的形式将 cookie 写入：\n``` php\n\tcurl_setopt($ch, CURLOPT_COOKIEFILE, $cookiefile);\n```\n\n**禁用SSL验证**\n有时候在抓取 Https 链接的时候以正常的方式去抓取会报错，此时需要在 cURL 会话中设置:\n``` php\ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\ncurl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n```\n通过上面的设置，可以禁用SSL证书的验证。\n\n以上即是目前我已经简单使用过的 cURL 库的内容，cURL 库还可以实现多线程抓取，实现 IP 代理等。其他内容会在之后的使用中学习到。\n","timeToRead":2}},{"node":{"id":"81096d4f-5dd0-5b1c-9fca-07c9e2d2f6ce","frontmatter":{"title":"知乎用户动态监控爬虫","date":"2015/11/25","tags":["Python","知乎"]},"fields":{"slug":"/posts/201511254"},"excerpt":"根据极客学院的Python爬虫教程写的一个单线程简易爬虫。可以监控知乎用户动态，当有新动态时发送邮件通知。 步骤 根据要关注的知乎用户的主页URL，使用requests模块获取整个用户主页的html。 根据用户主页及其html代码，定位所需要的最新动态的位置。 使用正则表达式比…","rawMarkdownBody":"\r\n> 根据极客学院的Python爬虫教程写的一个单线程简易爬虫。可以监控知乎用户动态，当有新动态时发送邮件通知。\r\n\r\n#### 步骤\r\n- 根据要关注的知乎用户的主页URL，使用requests模块获取整个用户主页的html。\r\n- 根据用户主页及其html代码，定位所需要的最新动态的位置。\r\n- 使用正则表达式比配到需要的数据。\r\n- 拼接数据，判断是否已经保持在文件中，即判断是否为新动态。\r\n- 若是新动态，使用python的smtplib模块发送收件到设置的邮箱中并保存到本地文件，否则略过。\r\n\r\n<!--more-->\r\n#### 模块\r\n`os`\r\n`time`\r\n`re`\r\n`sys`\r\n`MIMEText`\r\n`requests`\r\n`smtplib`\r\n<!--more-->\r\n\r\n#### zhihu类：获取与匹配，保持内容\r\n\r\n```\r\nclass zhihu(object):\r\n\r\n    def __init__(self):\r\n        # 设置关注的知乎用户\r\n        self.url = \"http://www.zhihu.com/people/xxxx\"\r\n        # 设置request header\r\n        self.header = {\r\n            'Host' : 'www.zhihu.com',\r\n            'Connection' : 'Keep-Alive',\r\n            'Accept' : 'text/html, application/xhtml+xml, image/jxr, */*',\r\n            'User-Agent' : 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36',\r\n            'Referer': self.url\r\n        }\r\n        # 设置登录的Cookie\r\n        self.cookie = {\r\n            'Cookie' : ''\r\n        }\r\n\r\n    # 获取知乎用户的主页HTML\r\n    def getHTML(self):\r\n        html = requests.get(self.url, headers = self.header, cookies = self.cookie).content\r\n        return html\r\n\r\n    # 获取最新动态\r\n    def getContent(self, html):\r\n        self.name = re.findall('<span class=\"name\">(.*?)</span>', html, re.S)[0]\r\n        content = re.findall('<div class=\"zm-profile-section-main zm-profile-section-activity-main zm-profile-activity-page-item-main\">(.*?)</div>', html, re.S)\r\n        return content\r\n\r\n    # 获取每一条最新动态\r\n    def getText(self, contents):\r\n        data = {}\r\n        data['href'] = re.findall('href=\"/question/(.*?)\"', contents, re.S)\r\n        data['question'] = re.findall('<a class=\"question_link\" .*?\">(.*?)</a>', contents, re.S)\r\n        restr = '\">'+ self.name +'</a>(.*?)\\n\\n<a'\r\n        data['action'] = re.findall(restr, contents, re.S)\r\n        text = self.name + data['action'] + ': ' +  data['question'] + ' http://www.zhihu.com/question/'+ data['href'] + '\\n'\r\n        return text\r\n\r\n    # 保存到文本\r\n    def toSave(self, text):\r\n        f = open('zhihu.txt', 'a')\r\n        f.write(text)\r\n        f.close()\r\n\r\n    # 检查动态是否已记录\r\n    def toCheck(self, text):\r\n        f = open('zhihu.txt', 'r')\r\n        existzhihu = f.readlines()\r\n        if text in existzhihu:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\n\r\n#### mail类：发送邮件\r\n\r\n```\r\nclass mail(object):\r\n\r\n    def __init__(self):\r\n        #邮件服务器地址，需要打开smtp\r\n        self.mail_host = \"smtp.xxx.cn\"\r\n        #邮件账号\r\n        self.mail_user = \"\"\r\n        #邮箱密码\r\n        self.mail_pass = \"\"\r\n        #邮箱后缀\r\n        self.mail_postfix = \"xxx.com\"\r\n\r\n    def sendMail(self, toList, sub, content):\r\n        #发信人\r\n        me = \"zhihu spider\" + \"<\" + self.mail_user + \"@\" + self.mail_postfix + \">\"\r\n        msg = MIMEText(content, _subtype='plain', _charset='utf-8')\r\n         #邮件标题\r\n        msg['Subject'] = sub\r\n        #邮件发送人\r\n        msg['From'] = me\r\n        #邮件收件人\r\n        msg['To'] = \";\".join(toList)\r\n        try:\r\n            server = smtplib.SMTP()\r\n            #连接服务器\r\n            server.connect(self.mail_host)\r\n            #登录邮箱\r\n            server.login(self.mail_user,self.mail_pass)\r\n            #发送邮件\r\n            server.sendmail(me, toList, msg.as_string())\r\n            server.close()\r\n            return True\r\n        except Exception, e:\r\n            print str(e)\r\n            return False\r\n\r\n```\r\n\r\n#### 运行\r\n\r\n```\r\nif __name__ == '__main__':\r\n    # 设置收件人邮箱\r\n    mailToList = ['xxx@xxx.com']\r\n    zhihu = zhihu();\r\n    while True:\r\n        html = zhihu.getHTML()\r\n        content = zhihu.getContent(html)\r\n        # 若没有动态记录，爬取所有动态，并保存\r\n        if not os.path.exists('zhihu.txt'):\r\n            for contents in content:\r\n                text = zhihu.getText(contents)\r\n                zhihu.toSave(text)\r\n        else:\r\n            text = zhihu.getText(content[0])\r\n            print text\r\n            # 检查是否存在记录， 不存在则发送邮件，并保存到文件\r\n            if zhihu.toCheck(text):\r\n                if mail().sendMail(mailToList, \"知乎动态\", text):\r\n                    zhihu.toSave(text)\r\n                    print \"发生成功\"\r\n                else:\r\n                    print \"发送失败\"\r\n            else:\r\n                print \"pass\"\r\n            # 每隔2分钟运行一次，检查新动态\r\n            time.sleep(120)\r\n```\r\n\r\n#### 总结\r\n这个简单的爬虫目前还没有办法同时关注很多用户，然后对ip也没有进行代理，爬取过于频繁的话可能会被封ip而爬取不到。\r\n\r\n在爬取知乎的过程中发现如果没有header,可能返回的html页面不是用户的主页。然后如果没有登录的话，看到的知乎用户的主页刷新缓慢。需要模拟登录后才能够实时刷新出新动态。\r\n\r\n同时使用的是re库正则匹配内容，在使用上不是很方便。但是对xpath又不是很熟，所以暂时使用正则取匹配。\r\n\r\n之前还有看到一个解析html内容的模块叫BeautifulSoup，准备去学习学习。然后打算下次使用pythopn的爬虫框架Scrapy来写更多功能的知乎爬虫。\r\n","timeToRead":3}},{"node":{"id":"b1554785-f692-59d2-87bd-2e3f26a1e7bc","frontmatter":{"title":"phpmyadmin 缺少 mcrypt 扩展","date":"2015/11/22","tags":["PHP","Ubuntu"]},"fields":{"slug":"/posts/201511223"},"excerpt":"记录，以便下次所需。 今天重装了腾讯云上面的服务器，安装的是Ubuntu server 14.04。搞完apache2 + mysql + PHP 后，安装了phpmyadmin来作为数据库管理。\n登录之后发现报错：缺少 mcrypt 扩展。上网查了一下，发现需要安装php-m…","rawMarkdownBody":"> 记录，以便下次所需。\r\n\r\n今天重装了腾讯云上面的服务器，安装的是Ubuntu server 14.04。搞完apache2 + mysql + PHP 后，安装了phpmyadmin来作为数据库管理。\r\n登录之后发现报错：缺少 mcrypt 扩展。上网查了一下，发现需要安装php-mcrypt、libmcrypt、libmcrypt-devel这三个。\r\n\r\n#### 安装mcrypt\r\n\tsudo apt-get install php-mcrypt libmcrypt libmcrypt-devel\r\n\r\n安装后重启apache2服务器后发现依然报错，后面在网上找到了解决办法。原来是在`/etc/php5/apache2/conf.d`下缺少一个`20-mcrypt.ini`。该文件是`mcrypt.ini`的链接。\r\n但是不知道是不是因为是版本不同的关系，这个文件的路径与搜索到的解决方案中不同。我的路径是：`/etc/php5/mods-available/mcrypt.ini`\r\n<!--more-->\r\n\r\n#### 链接mcrypt.ini\r\n\tsudo ln -s /etc/php5/mods-available/mcrypt.ini 20-mcrypt.ini\r\n\r\n\r\n这次重启apache2服务器后不报错了。\r\n\r\n#### 重启apache2\r\n\tsudo service apache2 restart\r\n","timeToRead":1}},{"node":{"id":"1d78a427-cc4e-5777-b94e-065a360529fe","frontmatter":{"title":"sudoers is world writable","date":"2015/08/30","tags":["Linux"]},"fields":{"slug":"/posts/201508301"},"excerpt":"记录以避免再次犯错 前因 今天修改.bashrc中的环境配置时，不小心把$PATH删除了。后来发现后添加回去后Terminal中出现如下错误： 这是因为sudoers的权限不对而出现的问题。 后果 在网上搜索后知道了解决方法是进入ubuntu的recovery mode将 的权…","rawMarkdownBody":"> 记录以避免再次犯错\r\n\r\n## 前因\r\n今天修改.bashrc中的环境配置时，不小心把$PATH删除了。后来发现后添加回去后Terminal中出现如下错误：\r\n\r\n\tsudo: /etc/sudoers is world writable\r\n\tsudo: no valid sudoers sources found, quitting\r\n\r\n<!--more-->\r\n\r\n这是因为sudoers的权限不对而出现的问题。\r\n\r\n## 后果\r\n在网上搜索后知道了解决方法是进入ubuntu的recovery mode将`/etc/soduers`的权限改为0440.\r\n\r\n然而这需要在recovery下使用root帐号，由于我没有设置root密码所以无法解决。\r\n\r\n最后终于找到了解决的办法，为了防止下次再次如此麻烦，将其记录下来。\r\n\r\n#### 具体步骤：\r\n- 开机按`Esc`进入GRUB，选择第二项\r\n- 选择recovery mode（一般是第二项），按`e`进入编辑\r\n- 将其中的`ro recovery nomodeset` 改为 `rw single init=/bin/bash`\r\n- 按F10，进入单用户模式，即root用户\r\n- 输入 `chomd 0440 /etc/sudoers` 修改权限\r\n- 按Ctrl + Alt + Del 重启\r\n\r\n重启后就可以使用sudo。这里出现了一个提示，进入/etc目录删除sudoers.d文件夹即可解决。\r\n","timeToRead":1}},{"node":{"id":"f2b11e32-39bd-5693-9f12-4e93a61213f2","frontmatter":{"title":"Ubuntu 下 LAMP环境搭建","date":"2015/08/24","tags":["Ubuntu","PHP"]},"fields":{"slug":"/posts/201508242"},"excerpt":"安装 安装apache2 安装php模块 安装Mysql 安装其他模块 测试Apache 浏览器访问  http://localhost/ 页面显示It Works！即为Apache服务器成功安装运行 修改权限 安装phpmyadmin 安装过程选择apache2,输入密码。 …","rawMarkdownBody":"\r\n## 安装\r\n\r\n### 安装apache2\r\n```\r\n$ sudo apt-get install apache2\r\n```\r\n\r\n### 安装php模块\r\n```\r\n$ sudo apt-get install php5\r\n```\r\n\r\n\r\n### 安装Mysql\r\n```\r\n$ sudo apt-get install mysql-server\r\n$ sudo apt-get install mysql-client\r\n```\r\n\r\n<!--more-->\r\n### 安装其他模块\r\n```\r\n$ sudo apt-get install libapache2-mod-php5\r\n$ sudo apt-get install libapache2-mod-auth-mysql\r\n$ sudo apt-get install php5-mysql\r\n$ sudo apt-get install php5-gd\r\n```\r\n\r\n### 测试Apache\r\n浏览器访问 [http://localhost/](http://localhost/)\r\n\r\n页面显示It Works！即为Apache服务器成功安装运行\r\n\r\n### 修改权限\r\n\r\n```\r\n$ sudo chmod 777 /var/www/html\r\n```\r\n\r\n### 安装phpmyadmin\r\n```\r\n$ sudo apt-get install phpmyadmin\r\n```\r\n\r\n安装过程选择apache2,输入密码。\r\n\r\n### 测试phpmyadmin\r\n```\r\n$ sudo ln -s /usr/share/phpmyadmin /var/www/html\r\n```\r\n\r\n浏览器访问 [http://localhost/phpmyadmin](http://localhost/phpmyadmin),并登录。\r\n\r\n## 配置\r\n\r\n### 启用mod_rewrite模块\r\n```\r\n$ sudo a2enmod rewrite\r\n```\r\n\r\n启用后重启Apache服务器：\r\n\r\n```\r\n$ sudo service apache2 restart\r\n```\r\n\r\n### 设置Apache支持 .htm .html .php\r\n```\r\n$ sudo gedit /etc/apache2/apache2.conf&\r\n```\r\n\r\n打开并添加：`AddType application/x-httpd-php .htm .html .php`\r\n\r\n### 测试PHP网页\r\n在/var/www/html下新建mysql_test.php:\r\n\r\n``` php\r\n<?php\r\n$link = mysql_connect(\"localhost\", \"root\", \"password\");\r\nif(!$link)\r\n  die('Could not connect: ' . mysql_error());\r\nelse\r\n  echo \"Mysql 配置正确!\";\r\nmysql_close($link);\r\n?>\r\n```\r\n\r\n访问 [http://localhost/mysql_test.php](http://localhost/mysql_test.php)，显示“Mysql配置正确”即完成\r\n","timeToRead":2}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}